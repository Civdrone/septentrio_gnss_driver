name: ci-new-design
run-name: ${{ github.event_name == 'workflow_dispatch' && format('C - {0} | S - {1} *{2} | P - {3} *{4}', github.event.inputs.commiter, github.event.inputs.source_repo, github.event.inputs.source_build, github.event.inputs.prev_repo, github.event.inputs.prev_build) || github.event.head_commit.message }}

on:
  workflow_dispatch:
    inputs:
      packages_build_paths:
        description: 'intput package to trigger build'
        required: true
        default: ''

      source_repo:
        description: 'Input source repository to trigger build'
        required: false
        default: ''
      source_build:
        description: 'Input source build number'
        required: false
        default: ''
      prev_repo:
        description: 'Input previous repository'
        required: false
        default: ''
      prev_build:
        description: 'Input previous build number'
        required: false
        default: ''
      commiter:
        description: 'Input of the commiter'
        required: false
        default: ''

      runner_amd_lable:
        description: 'aws self hosted runner amd lable to run jobs (optional)'
        required: false
        default: ''
      runner_arm_lable:
        description: 'aws self hosted runner arm lable to run jobs (optional)'
        required: false
        default: ''
      runner_arm_id:
        description: 'aws self hosted runner arm id to run jobs (optional)'
        required: false
        default: ''
      runner_amd_id:
        description: 'aws self hosted runner amd id to run jobs (optional)'
        required: false
        default: ''
  push:
    # branches-ignore:
      # - 'v[0-9]+.[0-9]+'
          
concurrency: lock-${{ github.ref }}

env:
  WORKSPACE_PATH: ${{ github.workspace }}
  COMMIT_ID: ${{ github.sha }}
  BUILD_NUMBER: ${{ github.run_number }}
  BRANCH: ${{ github.ref_name }}
  REPO_OWNER: ${{ github.repository_owner }}
  REPO: ${{ github.event.repository.name }}
  ROSDEP_MAP_FILE: ${{ secrets.rosdep_map_file }}
  ARTIFACTORY_TOKEN: ${{ secrets.artifactory_token }}
  ARTIFACTORY_URL: civrobotics.jfrog.io/artifactory/civros-unstable
  GH_TOKEN: ${{ secrets.gh_token }}
  AWS_REGION: us-east-1

jobs:
  initiate-workflow:
    runs-on: ubuntu-20.04
    timeout-minutes: 20
    outputs:
      label-arm: ${{ steps.start-arm-runner.outputs.label || steps.manual-input.outputs.label-arm }}
      arm-instance-id: ${{ steps.start-arm-runner.outputs.ec2-instance-id || steps.manual-input.outputs.ec2-instance-id-arm }}
      label-amd: ${{ steps.start-amd-runner.outputs.label || steps.manual-input.outputs.label-amd }}
      amd-instance-id: ${{ steps.start-amd-runner.outputs.ec2-instance-id || steps.manual-input.outputs.ec2-instance-id-amd }}
      promote-tag: ${{ steps.promote-tag.outputs.PROMOTED_TAG }}
      changed_packages_paths: ${{ steps.manual-input.outputs.changed_packages_paths || steps.changed-packages.outputs.changed_packages_paths }}
      packages_names: ${{ steps.manual-input.outputs.packages_names || steps.changed-packages.outputs.packages_names }}
      release_branch: ${{ steps.check-release.outputs.RELEASE_BRANCH }}
    steps:
      - name: checkout
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Check release branch
        id: check-release
        run: |
          if [[ $BRANCH =~ ^v[0-9]+\.[0-9]+$ ]]; then
              echo "RELEASE_BRANCH=true" >> $GITHUB_OUTPUT
              echo "RELEASE_BRANCH=true" >> "$GITHUB_ENV"
              echo "on release branch $BRANCH "
          fi
          
      - name: Check release promoteted tag
        id: promote-tag
        if: env.RELEASE_BRANCH == 'true'
        run: |
          # Run the command to check if the full build tag exists in civros-release
          git clone https://"Amir-civ:$GH_TOKEN"@github.com/Civdrone/civros-release.git
          cd civros-release

          # Check if the tag exists
          if git rev-parse "$BRANCH-promoted" >/dev/null 2>&1; then
            # The tag exists
            PROMOTED_TAG=$(git rev-parse "$BRANCH-promoted")
            echo "PROMOTED_TAG=true" >> "$GITHUB_OUTPUT"
            echo "PROMOTED_TAG=true" >> "$GITHUB_ENV"
          else
            # The tag does not exist
            echo "PROMOTED_TAG variable is empty"
            exit 1
          fi

      - name: Get unique changed packages
        id: changed-packages
        ## checks if trigger on push event, on release branch also checks for full build tag
        if: ${{ github.event_name == 'push' }}
        run: |
          mapfile -t CHANGED_FILES < <(git diff --name-only ${{ github.event.before }} ${{ github.event.after }})
          # Initialize unique_packages_paths
          unique_packages_paths=()

          for path in "${CHANGED_FILES[@]}"; do
            # if the path is a hidden directory or file, skip to the next iteration
            if [[ $path == .* ]]; then
              continue
            fi
            current_dirname="$(realpath "$path")"
            has_package_xml=false
            while [[ "$current_dirname" != "${GITHUB_WORKSPACE}" && $has_package_xml == false ]]; do
              current_dirname=$(dirname "$current_dirname")
              if [[ -f "${current_dirname}/package.xml" ]]; then
                has_package_xml=true
              fi
            done

            # Add if package.xml was found
            if [[ $has_package_xml == true ]]; then
              # change working directory of hosted runner to self hosted runner
              current_dirname="${current_dirname/\/home\/runner\/work/\/actions-runner\/_work}"
              unique_packages_paths+=("$current_dirname")
            fi
          done

          # Remove duplicates from the unique_packages_paths list
          unique_packages_paths=($(for path in "${unique_packages_paths[@]}"; do
            echo "$path"
          done | sort -u))

          # Output the list of unique packages paths
          echo "Changed packages: ${unique_packages_paths[@]}"

          # Set the `changed_packages_paths` environment variable with the list of unique packages paths
          echo "changed_packages_paths=${unique_packages_paths[*]}" >> "$GITHUB_OUTPUT"
          echo "changed_packages_paths=${unique_packages_paths[*]}" >> "$GITHUB_ENV"

          # Extract base names from paths and join them with a space
          packages_names=$(echo "${unique_packages_paths[*]}" | xargs -n 1 basename | xargs)
          echo "packages_names=${packages_names}" >> "$GITHUB_OUTPUT"

      - name: Get workflow manual input
        id: manual-input
        ## checks if trigger on dispatch event, on release branch also checks for full build tag
        if: ${{ github.event_name == 'workflow_dispatch' }}
        run: |
          # Split the input paths by spaces and store them in an array
          echo "paths: ${{ github.event.inputs.packages_build_paths }}"
          echo "arm lable: ${{ github.event.inputs.runner_arm_lable }}"
          echo "arm id: ${{ github.event.inputs.runner_arm_id }}"
          echo "amd lable: ${{ github.event.inputs.runner_amd_lable }}"
          echo "amd id: ${{ github.event.inputs.runner_amd_id }}"

          IFS=' ' read -ra paths <<< "${{ github.event.inputs.packages_build_paths }}"

          # Initialize an empty string to store the converted absolute paths
          converted_paths=""
          
          # Iterate over the paths array and convert each path to an absolute path using realpath
          for path in "${paths[@]}"; do
            absolute_path=$(realpath "$path")
            # change working directory of hosted runner to self hosted runner
            absolute_path="${absolute_path/\/home\/runner\/work/\/actions-runner\/_work}"
            converted_paths+=" $absolute_path"
          done
          
          # Remove leading space from the converted_paths string
          converted_paths="${converted_paths:1}"
          
          # Set the converted_paths string as the value in changed_packages_paths
          echo "changed_packages_paths=$converted_paths" >> "$GITHUB_OUTPUT"
          echo "changed_packages_paths=$converted_paths" >> "$GITHUB_ENV"
          echo "label-arm=${{ github.event.inputs.runner_arm_lable }}" >> "$GITHUB_OUTPUT"
          echo "label-amd=${{ github.event.inputs.runner_amd_lable }}" >> "$GITHUB_OUTPUT"
          echo "ec2-instance-id-arm=${{ github.event.inputs.runner_arm_id }}" >> "$GITHUB_OUTPUT"
          echo "ec2-instance-id-amd=${{ github.event.inputs.runner_amd_id }}" >> "$GITHUB_OUTPUT"

          # Extract base names from paths and join them with a space
          packages_names=$(echo "$converted_paths" | xargs -n 1 basename | xargs)
          echo "packages_names=${packages_names}" >> "$GITHUB_OUTPUT"

      - name: Configure AWS credentials
        if: ${{ github.event_name == 'push' && env.changed_packages_paths != '' || github.event_name == 'workflow_dispatch' && (steps.manual-input.outputs.label-arm == '' || steps.manual-input.outputs.label-amd == '') }}
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.CI_AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.CI_AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Start AMD runner
        if: ${{ github.event_name == 'push' && env.changed_packages_paths != '' || github.event_name == 'workflow_dispatch' && (steps.manual-input.outputs.label-arm == '' || steps.manual-input.outputs.label-amd == '') }}
        id: start-amd-runner
        uses: Amir-civ/ec2-github-runner@v1
        with:
          mode: start
          github-token: ${{ secrets.gh_token }}
          ec2-image-id: ami-0709e48fc2257176b
          ec2-instance-type: c5.2xlarge
          subnet-id: subnet-0ea80778fd45e76a0
          security-group-id: sg-095940a96979f1b1d

      - name: Start ARM runner
        if: ${{ github.event_name == 'push' && env.changed_packages_paths != '' || github.event_name == 'workflow_dispatch' && (steps.manual-input.outputs.label-arm == '' || steps.manual-input.outputs.label-amd == '') }}
        id: start-arm-runner
        uses: Amir-civ/ec2-github-runner@v1
        with:
          mode: start
          github-token: ${{ secrets.gh_token }}
          ec2-image-id: ami-05defeebd3c93ab8e
          ec2-instance-type: c6g.2xlarge
          subnet-id: subnet-0ea80778fd45e76a0
          security-group-id: sg-095940a96979f1b1d

  arm_build:
    needs: initiate-workflow # required to start the main job when the runner is ready
    if: needs.initiate-workflow.outputs.changed_packages_paths != ''
    runs-on: ${{ needs.initiate-workflow.outputs.label-arm }} # run the job on the newly created runner
    timeout-minutes: 20
    env:  # Set the environment variables at the job level
      promote-tag: ${{needs.initiate-workflow.outputs.promote-tag}}
      changed_packages_paths: ${{needs.initiate-workflow.outputs.changed_packages_paths}}
    steps:
      - name: checkout
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: additional env installations
        if: ${{ github.event_name != 'workflow_dispatch' }}
        run: |
          sudo ln -s /usr/include/eigen3/Eigen /usr/include/Eigen

      - name: Update artifactory server
        run: |
          # Get default branch
          default_branch=$(curl -H "Authorization: token $GH_TOKEN" -s https://api.github.com/repos/$REPO_OWNER/$REPO | jq -r '.default_branch')

          readarray -t branches < <(git show-branch -a | grep '\*' | awk 'match($0, /\[[^]]+\]/) { branch = substr($0, RSTART+1, RLENGTH-2); gsub(/origin\//, "", branch); gsub(/[~^].*/, "", branch); if (!seen[branch]++) print branch; if (branch == "develop" || branch == "main" || branch == "master") exit }' | uniq)

          # Iterate over the branches array until a match is found, then trim the array
          for ((idx=0; idx<${#branches[@]}; idx++)); do
              if [[ "${branches[idx]}" =~ ^v[0-9]+\.[0-9]+$ ]] || [[ "${branches[idx]}" == "$default_branch" ]]; then
                  branches=("${branches[@]:0:idx+1}")
                  break
              fi
          done

          priority=1001
          
          for branch in "${branches[@]}"; do
              sudo bash -c "cat >> /etc/apt/preferences.d/10-civ.pref << EOF
          Package: *
          Pin: release c='$branch'
          Pin-Priority: $priority
          
          EOF"
              priority=$((priority - 1))
              sudo sh -c "echo 'deb https://amir_b:$ARTIFACTORY_TOKEN@$ARTIFACTORY_URL galactic $branch' >> /etc/apt/sources.list.d/civ.list"
          done
          
          sudo cat /etc/apt/preferences.d/10-civ.pref
          sudo cat /etc/apt/sources.list.d/civ.list
          wget -O civrobotics.pub https://amir_b:$ARTIFACTORY_TOKEN@civrobotics.jfrog.io/artifactory/api/security/keypair/debianKeys/public
          gpg --import civrobotics.pub
          gpg --list-keys
          sudo apt-key add civrobotics.pub
          sudo apt update
          # downloading rosdep mapping file
          sudo curl -u "Amir-civ:$GH_TOKEN" -L $ROSDEP_MAP_FILE -o /etc/ros/rosdep/sources.list.d/local.yaml
          if [ $? -eq 0 ]; then
            echo "YAML file downloaded successfully!"
          else
            echo "Failed to download YAML file."
          fi
          sudo sh -c 'echo "yaml file:///etc/ros/rosdep/sources.list.d/local.yaml" >> /etc/ros/rosdep/sources.list.d/20-default.list'

      - name: Build deb package
        id: build_deb_package
        run: |
          built_packages=true
          IFS=' ' read -ra packages_paths <<< "$changed_packages_paths"
          for package_path in "${packages_paths[@]}"; do
            pwd
            ls
            cd "$package_path"
            pwd
            ls
            sed -E -i "s/<version>([0-9]+)\.([0-9]+)\.([0-9]+)<\/version>/<version>\1.\2.${BUILD_NUMBER}<\/version>/" package.xml
            source /opt/ros/galactic/setup.bash
            rosdep update --include-eol-distros
            bloom-generate rosdebian
            sudo apt update
            sudo apt build-dep . -y
            dpkg-buildpackage -b -rfakeroot -us -uc
            cd ..
            # ls | grep .deb
            if ! ls *.deb 1>/dev/null 2>&1; then
              built_packages=false
            fi
          done
          echo "built_packages=$built_packages" >> $GITHUB_ENV

      - name: Push to artifactory server
        if: ${{ env.built_packages == 'true' }}
        run: |
          # convert the list to an array
          IFS=' ' read -ra changed_packages_paths_arry <<< "$changed_packages_paths"

          # use an associative array(bash dictionary) to handle duplicates
          declare -A debian_packages_paths

          # loop over each path, get the dirname and add it to the associative array(bash dictionary)
          for i in "${changed_packages_paths_arry[@]}"; do
            dirname=$(dirname "$i")
            debian_packages_paths["$dirname"]=1
          done

          # now debian_packages_paths is a list with unique directories, so we can iterate over it
          for dir in "${!debian_packages_paths[@]}"; do
            echo "Processing directory $dir"
            cd "$dir"
            
            # your script comes here
            PACKS=($(ls ${1:-.}/*.deb))
            echo "$PACKS"
            for pack in "${PACKS[@]}"
            do
                name=$(basename "$pack")
                printf "\nPublishing %s\n" "$name"
                
                dirname=$(cut -d '_' -f1 <<< "$name")
                #push them to Artifactory
                curl --fail -uamir_b:$ARTIFACTORY_TOKEN -XPUT "https://$ARTIFACTORY_URL/galactic/${dirname}/${BRANCH}/${name};deb.distribution=galactic;deb.component=$BRANCH;deb.architecture=$(dpkg --print-architecture);deb.build_number=$BUILD_NUMBER" -T $pack -o $dirname.json
                cat $dirname.json
            done

            # get back to the initial directory, so that relative paths work in the next iteration
            cd -
          done

      - name: Update rosdep yaml file
        if: ${{ env.built_packages == 'true' }}
        run: |
          export HOME=/home/ubuntu
          git clone https://"Amir-civ:$GH_TOKEN"@github.com/Civdrone/scripts.git
          cd scripts
          git checkout ci-github-actions
          IFS=' ' read -ra packages_paths <<< "$changed_packages_paths"
          for package_path in "${packages_paths[@]}"; do
            # Check if package path is root
            if [[ $package_path == "." ]]; then
              package_name=$REPO
            else
              package_name=$(basename "$package_path")
            fi
      
            package_exists=$(yq ".$package_name" ./docker_container/local.yaml)
            if [[ $package_exists = null ]]; then
              # Define the apt package
              apt_package=$(echo "$package_name" | sed 's/_/-/g; s/^/ros-galactic-/')
              
              # Create the YAML content for the new package
              new_yaml_content="${package_name}:\n  ubuntu:\n    focal: [${apt_package}]"
              
              # Read the existing YAML content from the file
              existing_yaml_content=$(sudo cat ./docker_container/local.yaml)
              
              # Append the new package information to the existing YAML content
              yaml_content="${existing_yaml_content}\n${new_yaml_content}"
              
              # Write the modified YAML content to the file
              echo -e "${yaml_content}" > ./docker_container/local.yaml
              # Push changes to remote
              git config --global user.email "amir@civrobotics.com"
              git config --global user.name "amir-ci"
              git add .
              git commit -m "changed rosdep yaml file from ci, owner/repo: ${REPO}, branch: ${BRANCH}  build number: ${BUILD_NUMBER}."
              git push origin ci-github-actions
            else
              echo "$package_name exists"
            fi
          done       

      - name: Update commit status and cencel all workflows with the same branch on failure
        if: ${{ failure() }}
        run: |
          if [[ $BRANCH =~ ^v[0-9]+\.[0-9]+$ ]]; then
            sudo curl -u "Amir-civ:$GH_TOKEN" -L https://raw.githubusercontent.com/$REPO_OWNER/civros-release/$BRANCH/repo.csv -o ./repo.csv
          else
            sudo curl -u "Amir-civ:$GH_TOKEN" -L https://raw.githubusercontent.com/$REPO_OWNER/civros-release/develop/repo.csv -o ./repo.csv
          fi
          
          if [ $? -eq 0 ]; then
              echo "repo.csv file downloaded successfully!"
          else
              echo "Failed to download repo.csv file."
          fi

          # Read the CSV file and cencel repositories
          while IFS=, read -r repo || [ -n "$repo" ]; do
            # Get the most recent workflow run ID for the specified event and branch
            run_id=$(curl -s -H "Authorization: Bearer $GH_TOKEN" \
            "https://api.github.com/repos/$REPO_OWNER/$repo/actions/runs?branch=$BRANCH" \
            | jq -r '.workflow_runs[0].id')

            # Cancel the workflow run if a run ID is found
            if [ "$run_id" != "null" ]; then
                curl -X POST -s -H "Authorization: Bearer $GH_TOKEN" \
                "https://api.github.com/repos/$REPO_OWNER/$repo/actions/runs/$run_id/cancel"

                echo "Workflow run $run_id has been canceled"
            else
                echo "No workflow run found for $repo"
            fi
          done < ./repo.csv
          # update commit status
          curl -X POST -H "Authorization: token $GH_TOKEN" -H "Accept: application/vnd.github.v3+json" https://api.github.com/repos/$REPO_OWNER/$REPO/statuses/${COMMIT_ID} -d '{"state": "failure", "context": "continuous-integration/build-${BUILD_NUMBER"}'

      - name: Discard Local Changes
        if: ${{ always() }}
        run: |
          cd $GITHUB_WORKSPACE
          git checkout -- .
          git clean -f
          
      - name: Post to a Slack channel
        if: ${{ always() }}
        id: slack
        uses: slackapi/slack-github-action@v1.23.0
        with:
          channel-id: 'C051SPVTW2Z'
          slack-message: |
            GitHub build result: ${{ job.status }}
            Workflow: ${{ github.job }}
            Repository: ${{ github.event.repository.name }}
            Packages: ${{needs.initiate-workflow.outputs.packages_names}}
            Branch: ${{ github.ref_name }}
            Build Number: ${{ github.run_number }}
            Triggered by: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.commiter || github.actor}}
            Workflow URL: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}

  amd_build:
    needs: initiate-workflow # required to start the main job when the runner is ready
    if: needs.initiate-workflow.outputs.changed_packages_paths != ''
    runs-on: ${{ needs.initiate-workflow.outputs.label-amd }} # run the job on the newly created runner
    timeout-minutes: 20
    env:  # Set the environment variables at the job level
      promote-tag: ${{needs.initiate-workflow.outputs.promote-tag}}
      changed_packages_paths: ${{needs.initiate-workflow.outputs.changed_packages_paths}}
    
    steps:
      - name: checkout
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: additional env installations
        if: ${{ github.event_name != 'workflow_dispatch' }}
        run: |
          sudo ln -s /usr/include/eigen3/Eigen /usr/include/Eigen

      - name: Update artifactory server
        run: |
          # Get default branch
          default_branch=$(curl -H "Authorization: token $GH_TOKEN" -s https://api.github.com/repos/$REPO_OWNER/$REPO | jq -r '.default_branch')

          readarray -t branches < <(git show-branch -a | grep '\*' | awk 'match($0, /\[[^]]+\]/) { branch = substr($0, RSTART+1, RLENGTH-2); gsub(/origin\//, "", branch); gsub(/[~^].*/, "", branch); if (!seen[branch]++) print branch; if (branch == "develop" || branch == "main" || branch == "master") exit }' | uniq)

          # Iterate over the branches array until a match is found, then trim the array
          for ((idx=0; idx<${#branches[@]}; idx++)); do
              if [[ "${branches[idx]}" =~ ^v[0-9]+\.[0-9]+$ ]] || [[ "${branches[idx]}" == "$default_branch" ]]; then
                  branches=("${branches[@]:0:idx+1}")
                  break
              fi
          done

          priority=1001
          
          for branch in "${branches[@]}"; do
              sudo bash -c "cat >> /etc/apt/preferences.d/10-civ.pref << EOF
          Package: *
          Pin: release c='$branch'
          Pin-Priority: $priority
          
          EOF"
              priority=$((priority - 1))
              sudo sh -c "echo 'deb https://amir_b:$ARTIFACTORY_TOKEN@$ARTIFACTORY_URL galactic $branch' >> /etc/apt/sources.list.d/civ.list"
          done
          
          sudo cat /etc/apt/preferences.d/10-civ.pref
          sudo cat /etc/apt/sources.list.d/civ.list
          wget -O civrobotics.pub https://amir_b:$ARTIFACTORY_TOKEN@civrobotics.jfrog.io/artifactory/api/security/keypair/debianKeys/public
          gpg --import civrobotics.pub
          gpg --list-keys
          sudo apt-key add civrobotics.pub
          sudo apt update
          # downloading rosdep mapping file
          sudo curl -u "Amir-civ:$GH_TOKEN" -L $ROSDEP_MAP_FILE -o /etc/ros/rosdep/sources.list.d/local.yaml
          if [ $? -eq 0 ]; then
            echo "YAML file downloaded successfully!"
          else
            echo "Failed to download YAML file."
          fi
          sudo sh -c 'echo "yaml file:///etc/ros/rosdep/sources.list.d/local.yaml" >> /etc/ros/rosdep/sources.list.d/20-default.list'

      - name: Build deb package
        id: build_deb_package
        run: |
          built_packages=true
          IFS=' ' read -ra packages_paths <<< "$changed_packages_paths"
          for package_path in "${packages_paths[@]}"; do
            pwd
            ls
            cd "$package_path"
            pwd
            ls
            sed -E -i "s/<version>([0-9]+)\.([0-9]+)\.([0-9]+)<\/version>/<version>\1.\2.${BUILD_NUMBER}<\/version>/" package.xml
            source /opt/ros/galactic/setup.bash
            rosdep update --include-eol-distros
            bloom-generate rosdebian
            sudo apt update
            sudo apt build-dep . -y
            dpkg-buildpackage -b -rfakeroot -us -uc
            cd ..
            # ls | grep .deb
            if ! ls *.deb 1>/dev/null 2>&1; then
              built_packages=false
            fi
          done
          echo "built_packages=$built_packages" >> $GITHUB_ENV

      - name: Push to artifactory server
        if: ${{ env.built_packages == 'true' }}
        run: |
          # convert the list to an array
          IFS=' ' read -ra changed_packages_paths_arry <<< "$changed_packages_paths"

          # use an associative array(bash dictionary) to handle duplicates
          declare -A debian_packages_paths

          # loop over each path, get the dirname and add it to the associative array(bash dictionary)
          for i in "${changed_packages_paths_arry[@]}"; do
            dirname=$(dirname "$i")
            debian_packages_paths["$dirname"]=1
          done

          # now debian_packages_paths is a list with unique directories, so we can iterate over it
          for dir in "${!debian_packages_paths[@]}"; do
            echo "Processing directory $dir"
            cd "$dir"
            
            # your script comes here
            PACKS=($(ls ${1:-.}/*.deb))
            echo "$PACKS"
            for pack in "${PACKS[@]}"
            do
                name=$(basename "$pack")
                printf "\nPublishing %s\n" "$name"
                
                dirname=$(cut -d '_' -f1 <<< "$name")
                #push them to Artifactory
                curl --fail -uamir_b:$ARTIFACTORY_TOKEN -XPUT "https://$ARTIFACTORY_URL/galactic/${dirname}/${BRANCH}/${name};deb.distribution=galactic;deb.component=$BRANCH;deb.architecture=$(dpkg --print-architecture);deb.build_number=$BUILD_NUMBER" -T $pack -o $dirname.json
                cat $dirname.json
            done

            # get back to the initial directory, so that relative paths work in the next iteration
            cd -
          done

      - name: Update rosdep yaml file
        if: ${{ env.built_packages == 'true' }}
        run: |
          export HOME=/home/ubuntu
          git clone https://"Amir-civ:$GH_TOKEN"@github.com/Civdrone/scripts.git
          cd scripts
          git checkout ci-github-actions
          IFS=' ' read -ra packages_paths <<< "$changed_packages_paths"
          for package_path in "${packages_paths[@]}"; do
            # Check if package path is root
            if [[ $package_path == "." ]]; then
              package_name=$REPO
            else
              package_name=$(basename "$package_path")
            fi
      
            package_exists=$(yq ".$package_name" ./docker_container/local.yaml)
            if [[ $package_exists = null ]]; then
              # Define the apt package
              apt_package=$(echo "$package_name" | sed 's/_/-/g; s/^/ros-galactic-/')
              
              # Create the YAML content for the new package
              new_yaml_content="${package_name}:\n  ubuntu:\n    focal: [${apt_package}]"
              
              # Read the existing YAML content from the file
              existing_yaml_content=$(sudo cat ./docker_container/local.yaml)
              
              # Append the new package information to the existing YAML content
              yaml_content="${existing_yaml_content}\n${new_yaml_content}"
              
              # Write the modified YAML content to the file
              echo -e "${yaml_content}" > ./docker_container/local.yaml
              # Push changes to remote
              git config --global user.email "amir@civrobotics.com"
              git config --global user.name "amir-ci"
              git add .
              git commit -m "changed rosdep yaml file from ci, owner/repo: ${REPO}, branch: ${BRANCH}  build number: ${BUILD_NUMBER}."
              git push origin ci-github-actions
            else
              echo "$package_name exists"
            fi
          done       

      - name: Update commit status and cencel all workflows with the same branch on failure
        if: ${{ failure() }}
        run: |
          if [[ $BRANCH =~ ^v[0-9]+\.[0-9]+$ ]]; then
            sudo curl -u "Amir-civ:$GH_TOKEN" -L https://raw.githubusercontent.com/$REPO_OWNER/civros-release/$BRANCH/repo.csv -o ./repo.csv
          else
            sudo curl -u "Amir-civ:$GH_TOKEN" -L https://raw.githubusercontent.com/$REPO_OWNER/civros-release/develop/repo.csv -o ./repo.csv
          fi
          if [ $? -eq 0 ]; then
              echo "repo.csv file downloaded successfully!"
          else
              echo "Failed to download repo.csv file."
          fi

          # Read the CSV file and cencel repositories
          while IFS=, read -r repo || [ -n "$repo" ]; do
          # Get the most recent workflow run ID for the specified event and branch
          run_id=$(curl -s -H "Authorization: Bearer $GH_TOKEN" \
          "https://api.github.com/repos/$REPO_OWNER/$repo/actions/runs?branch=$BRANCH" \
          | jq -r '.workflow_runs[0].id')

          # Cancel the workflow run if a run ID is found
          if [ "$run_id" != "null" ]; then
              curl -X POST -s -H "Authorization: Bearer $GH_TOKEN" \
              "https://api.github.com/repos/$REPO_OWNER/$repo/actions/runs/$run_id/cancel"

              echo "Workflow run $run_id has been canceled"
          else
              echo "No workflow run found for $repo"
          fi
          done < ./repo.csv
          # update commit status
          curl -X POST -H "Authorization: token $GH_TOKEN" -H "Accept: application/vnd.github.v3+json" https://api.github.com/repos/$REPO_OWNER/$REPO/statuses/${COMMIT_ID} -d '{"state": "failure", "context": "continuous-integration/build-${BUILD_NUMBER"}'

      - name: Discard Local Changes
        if: ${{ always() }}
        run: |
          cd $GITHUB_WORKSPACE
          git checkout -- .
          git clean -f
          
      - name: Post to a Slack channel
        if: ${{ always() }}
        id: slack
        uses: slackapi/slack-github-action@v1.23.0
        with:
          channel-id: 'C051SPVTW2Z'
          slack-message: |
            GitHub build result: ${{ job.status }}
            Workflow: ${{ github.job }}
            Repository: ${{ github.event.repository.name }}
            Packages: ${{needs.initiate-workflow.outputs.packages_names}}
            Branch: ${{ github.ref_name }}
            Build Number: ${{ github.run_number }}
            Triggered by: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.commiter || github.actor}}
            Workflow URL: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}

  depends_on_trigger:
    needs: [amd_build, arm_build, initiate-workflow]
    if: ${{ github.event_name == 'workflow_dispatch' && (github.ref_name == 'develop' || needs.initiate-workflow.outputs.RELEASE_BRANCH == 'true') && needs.amd_build.result == 'success' && needs.arm_build.result == 'success' }}
    runs-on: ${{ needs.initiate-workflow.outputs.label-amd }} # run the job on the newly created runner
    timeout-minutes: 20
    outputs:
      recursion_ends: ${{ steps.trigger-depends-pacakge.outputs.recursion_ends }}
    env:  # Set the environment variables at the job level
      promote-tag: ${{needs.initiate-workflow.outputs.promote-tag}}
      changed_packages_paths: ${{needs.initiate-workflow.outputs.changed_packages_paths}}
      label_arm: ${{needs.initiate-workflow.outputs.label-arm}}
      label_amd: ${{needs.initiate-workflow.outputs.label-amd}}
      arm_instance_id: ${{needs.initiate-workflow.outputs.arm-instance-id}}
      amd_instance_id: ${{needs.initiate-workflow.outputs.amd-instance-id}}
    steps:
    - name: checkout
      uses: actions/checkout@v3
      with:
        fetch-depth: 0

    - name: Trigger task that depends on packages
      id: trigger-depends-pacakge
      run: |
        echo "Changed package paths: $changed_packages_paths"
        mkdir ros_ws && cd ros_ws
        # Download repo.csv
        if [[ $BRANCH =~ ^v[0-9]+\.[0-9]+$ ]]; then
          sudo curl -u "Amir-civ:$GH_TOKEN" -L https://raw.githubusercontent.com/$REPO_OWNER/civros-release/$BRANCH/repo.csv -o ./repo.csv
        else
          sudo curl -u "Amir-civ:$GH_TOKEN" -L https://raw.githubusercontent.com/$REPO_OWNER/civros-release/develop/repo.csv -o ./repo.csv
        fi

        if [ $? -eq 0 ]; then
            echo "repo.csv file downloaded successfully!"
        else
            echo "Failed to download repo.csv file."
        fi
        
        # Read the CSV file and clone repositories
        while IFS=, read -r repo || [ -n "$repo" ]; do
            git clone -b $BRANCH https://"$Amir-civ":"${GH_TOKEN}"@github.com/Civdrone/"$repo".git
        done < ./repo.csv
        
        # Source ROS 2 Galactic installation
        source /opt/ros/galactic/setup.bash
        
        # Run colcon list --topological-order command and extract the first fraction from each line
        build_order=$(colcon list --topological-order | awk '{print $1}')
        build_order_arry=($build_order)
        packages_paths_arry=($changed_packages_paths)
        recursion_ends="false"

        for i in "${!build_order_arry[@]}"; do
            for package_path in "${packages_paths_arry[@]}"; do
                if [[ ${build_order_arry[$i]} = $(basename "$package_path") ]]; then
                    next_packages_arry=("${build_order_arry[@]:$((i+1))}")
                    break 2
                fi
            done
        done

        if [[ ${#next_packages_arry[@]} -gt 0 ]]; then
            echo "next package: ${next_packages_arry[0]}"
        else
            echo "No next packages found."
            recursion_ends="true"
        fi

        # Identify unique repositories containing the packages in the new list paths and create a separate list
        package_path_in_ros_ws=$(find . -type d -name "${next_packages_arry[0]}" -exec test -e "{}/package.xml" \; -print -quit)
        
        if [[ -z "$package_path_in_ros_ws" ]]; then
          echo "The package_path_in_ros_ws value is empty."
        fi

        next_repo=$(echo $package_path_in_ros_ws | cut -d'/' -f2)
        next_package_path=$(echo $package_path_in_ros_ws | cut -d'/' -f3-)

        echo "recursion_ends=$recursion_ends" >> "$GITHUB_OUTPUT"

        if [[ $recursion_ends == "false" ]]; then

          if [[ -z "$next_package_path" ]]; then
            echo "Next package path is empty, assining relative path."
            next_package_path="."
          fi

          # Trigger workflow using GitHub API
          echo "next packages: ${build_order_arry[@]}"
          echo "next repo: $next_repo"
          echo "next package: $next_package_path"
          # response=$(curl -s -o /dev/null -w "%{http_code}" -X POST https://api.github.com/repos/$REPO_OWNER/$next_repo/actions/workflows/dev-ci.yaml/dispatches -H "Accept: application/vnd.github.v3+json" -H "Authorization: token $GH_TOKEN" --data '{"ref": "'$BRANCH'", "inputs": {"packages_build_paths": "'$next_package_path'"}}')
          echo "'$amd_instance_id'"
          echo "'$label_amd'"
          echo "'$arm_instance_id'"
          echo "'$label_arm'"

          source_repo=${{  github.event_name == 'workflow_dispatch' && github.event.inputs.source_repo || env.REPO }}
          source_build=${{  github.event_name == 'workflow_dispatch' && github.event.inputs.source_build || env.BUILD_NUMBER }}
          prev_repo=${{ env.REPO }}
          prev_build=${{ env.BUILD_NUMBER }}
          commiter=${{ github.event_name == 'workflow_dispatch' && github.event.inputs.commiter || github.actor}}

          # echo "source_repo=$source_repo" >> $GITHUB_ENV
          # echo "source_build=$source_build" >> $GITHUB_ENV
          # echo "commiter=$commiter" >> $GITHUB_ENV

          response=$(curl -s -o /dev/null -w "%{http_code}" -X POST \
          https://api.github.com/repos/$REPO_OWNER/$next_repo/actions/workflows/CI.yaml/dispatches \
          -H "Accept: application/vnd.github.v3+json" \
          -H "Authorization: token $GH_TOKEN" \
          --data '{
            "ref": "'$BRANCH'",
            "inputs": {
              "packages_build_paths": "'$next_package_path'",
              "runner_amd_lable": "'$label_amd'",
              "runner_arm_lable": "'$label_arm'",
              "runner_arm_id": "'$arm_instance_id'",
              "runner_amd_id": "'$amd_instance_id'",
              "source_repo": "'$source_repo'",
              "source_build": "'$source_build'",
              "prev_repo": "'$prev_repo'",
              "prev_build": "'$prev_build'",
              "commiter": "'$commiter'"
            }
          }')       
          if [ "$response" -ne 204 ]; then
            echo "Failed to trigger the workflow. HTTP status was: $response"
            exit 1
          fi
          curl -X POST -u amir_b:$ARTIFACTORY_TOKEN "https://civrobotics.jfrog.io/artifactory/api/deb/reindex/civros-unstable?writeProps=0"
        fi

    - name: Discard Local Changes
      if: ${{ always() }}
      run: |
        cd $GITHUB_WORKSPACE
        git checkout -- .
        git clean -f

    - name: Post to a Slack channel
      if: ${{ failure() || cancelled() || steps.trigger-depends-pacakge.outputs.recursion_ends == 'true' }}
      id: slack
      uses: slackapi/slack-github-action@v1.23.0
      with:
        # Slack channel id, channel name, or user id to post message.
        # See also: https://api.slack.com/methods/chat.postMessage#channels
        # You can pass in multiple channels to post to by providing a comma-delimited list of channel IDs.
        channel-id: 'C051SPVTW2Z'
        # For posting a simple plain text message
        slack-message: |
          GitHub build result: ${{ job.status }}
          Workflow: ${{ github.job }}
          Repository: ${{ github.event.repository.name }}
          Branch: ${{ github.ref_name }}
          Build Number: ${{ github.run_number }}
          Triggered by: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.commiter || github.actor}}
          Full Build Status: ${{  steps.trigger-depends-pacakge.outputs.recursion_ends == 'true' && 'success' || 'faild' }}
          Source Repository: ${{  github.event_name == 'workflow_dispatch' && github.event.inputs.source_repo || env.REPO }}
          Source Build Number: ${{  github.event_name == 'workflow_dispatch' && github.event.inputs.source_build || env.BUILD_NUMBER }}
          Workflow URL: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
      env:
        SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
        
  stop-runners:
    needs: [initiate-workflow, arm_build, amd_build, depends_on_trigger]
    runs-on: ubuntu-20.04
    timeout-minutes: 20
    if: |
      always() && (needs.initiate-workflow.outputs.label-amd != null || needs.initiate-workflow.outputs.label-arm != null) &&
      (github.event_name != 'workflow_dispatch' || (needs.depends_on_trigger.result != 'success' || (needs.depends_on_trigger.result == 'success' && needs.depends_on_trigger.outputs.recursion_ends == 'true')))

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.CI_AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.CI_AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Stop AMD runner
        uses: Amir-civ/ec2-github-runner@v1
        with:
          mode: stop
          github-token: ${{ secrets.gh_token }}
          label: ${{ needs.initiate-workflow.outputs.label-amd }}
          ec2-instance-id: ${{ needs.initiate-workflow.outputs.amd-instance-id }}

      - name: Stop ARM runner
        uses: Amir-civ/ec2-github-runner@v1
        with:
          mode: stop
          github-token: ${{ secrets.gh_token }}
          label: ${{ needs.initiate-workflow.outputs.label-arm }}
          ec2-instance-id: ${{ needs.initiate-workflow.outputs.arm-instance-id }}