name: ci-new-design
run-name: ${{ format('Commiter - {0} | msg - {1}', github.actor, github.event.head_commit.message || 'none') }}

on:
  workflow_dispatch:
    inputs:
      packages_build_paths:
        description: 'input packages for build (seperated by spaces)'
        required: true
        default: ''
  push:
    # branches-ignore:
      # - 'v[0-9]+.[0-9]+'

concurrency: lock-${{ github.ref }}

env:
  WORKSPACE_PATH: ${{ github.workspace }}
  COMMIT_ID: ${{ github.sha }}
  BUILD_NUMBER: ${{ github.run_number }}
  BRANCH: ${{ github.ref_name }}
  REPO_OWNER: ${{ github.repository_owner }}
  REPO: ${{ github.event.repository.name }}
  ROSDEP_MAP_FILE: ${{ secrets.rosdep_map_file }}
  ARTIFACTORY_TOKEN: ${{ secrets.artifactory_token }}
  ARTIFACTORY_URL: civrobotics.jfrog.io/artifactory/civros-unstable
  GH_TOKEN: ${{ secrets.gh_token }}
  AWS_REGION: us-east-1
  ROS_DIST: galactic

jobs:
  initiate-workflow:
    runs-on: ubuntu-20.04
    timeout-minutes: 20
    outputs:
      label-arm: ${{ steps.start-arm-runner.outputs.label }}
      arm-instance-id: ${{ steps.start-arm-runner.outputs.ec2-instance-id }}
      label-amd: ${{ steps.start-amd-runner.outputs.label }}
      amd-instance-id: ${{ steps.start-amd-runner.outputs.ec2-instance-id }}
      promote-tag: ${{ steps.promote-tag.outputs.PROMOTED_TAG }}
      changed_packages_paths: ${{ steps.manual-input.outputs.changed_packages_paths || steps.changed-packages.outputs.changed_packages_paths }}
      release_branch: ${{ steps.check-release.outputs.RELEASE_BRANCH }}
      runners_matrix: ${{ steps.runners-matrix.outputs.runners_matrix }}
      major_minor: ${{ steps.ensure-version.outputs.major_minor }}
    steps:
      - name: checkout
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Setup JFrog CLI
        uses: jfrog/setup-jfrog-cli@v3.4.0
        env:
          JF_URL: https://civrobotics.jfrog.io
          JF_USER: amir_b
          JF_PASSWORD: ${{ secrets.artifactory_token }}

      - name: Check release branch
        id: check-release
        run: |
          if [[ $BRANCH =~ ^v[0-9]+\.[0-9]+$ ]]; then
              echo "RELEASE_BRANCH=true" >> $GITHUB_OUTPUT
              echo "RELEASE_BRANCH=true" >> "$GITHUB_ENV"
              echo "on release branch $BRANCH"
          fi
          
      - name: Check release promoteted tag
        id: promote-tag
        if: env.RELEASE_BRANCH == 'true'
        run: |
          # Run the command to check if the full build tag exists in civros-release
          git clone https://"Amir-civ:$GH_TOKEN"@github.com/Civdrone/civros-release.git
          cd civros-release
          # Check if the tag exists
          if git rev-parse "$BRANCH-promoted" >/dev/null 2>&1; then
            # The tag exists
            PROMOTED_TAG=$(git rev-parse "$BRANCH-promoted")
            echo "PROMOTED_TAG=true" >> "$GITHUB_OUTPUT"
            echo "PROMOTED_TAG=true" >> "$GITHUB_ENV"
          else
            # The tag does not exist
            echo "PROMOTED_TAG variable is empty"
            exit 1
          fi

      - name: Get unique changed packages
        id: changed-packages
        ## checks if trigger on push event, on release branch also checks for full build tag
        if: ${{ github.event_name == 'push' }}
        run: |
          # Initialize unique_packages_paths
          unique_packages_paths=()
          if [[ "${{ github.event.before }}" == "0000000000000000000000000000000000000000" ]]; then
            # For the first commit on a new branch, compare it to the commit before
            mapfile -t CHANGED_FILES < <(git diff --name-status ${{ github.event.after }}~1 ${{ github.event.after }})
          else
            # For most cases, compare the state before and after the push
            mapfile -t CHANGED_FILES < <(git diff --name-status ${{ github.event.before }} ${{ github.event.after }})
          fi
          for line in "${CHANGED_FILES[@]}"; do
            status="${line:0:1}"
            path="${line:2}"
            
            # Skip deleted files
            if [[ "$status" == "D" ]]; then
              continue
            fi
            
            # Skip hidden directories or files
            if [[ "$path" =~ ^\..* ]]; then
              continue
            fi
            
            # Check if file or directory exists
            if [[ -e "$path" ]]; then
              current_dirname="$(realpath "$path")"
              has_package_xml=false
              while [[ "$current_dirname" != "${GITHUB_WORKSPACE}" && $has_package_xml == false ]]; do
                current_dirname=$(dirname "$current_dirname")
                if [[ -f "${current_dirname}/package.xml" ]]; then
                  has_package_xml=true
                fi
              done
            
              # Add if package.xml was found
              if [[ $has_package_xml == true ]]; then
                current_dirname="${current_dirname/\/home\/runner\/work/\/actions-runner\/_work}"
                unique_packages_paths+=("$current_dirname")
              fi
            fi
          done
          # Remove duplicates from the unique_packages_paths list
          unique_packages_paths=($(for path in "${unique_packages_paths[@]}"; do
            echo "$path"
          done | sort -u))
          echo "Changed packages: ${unique_packages_paths[@]}"
          echo "changed_packages_paths=${unique_packages_paths[*]}" >> "$GITHUB_OUTPUT"
          echo "changed_packages_paths=${unique_packages_paths[*]}" >> "$GITHUB_ENV"

      - name: Get workflow manual input
        id: manual-input
        ## checks if trigger on dispatch event, on release branch also checks for full build tag
        if: ${{ github.event_name == 'workflow_dispatch' }}
        run: |
          # Split the input paths by spaces and store them in an array
          IFS=' ' read -ra paths <<< "${{ github.event.inputs.packages_build_paths }}"
          # Initialize an empty string to store the converted absolute paths
          converted_paths=""
          
          # Iterate over the paths array and convert each path to an absolute path using realpath
          for path in "${paths[@]}"; do
            absolute_path=$(realpath "$path")
            # change working directory of hosted runner to self hosted runner
            absolute_path="${absolute_path/\/home\/runner\/work/\/actions-runner\/_work}"
            converted_paths+=" $absolute_path"
          done
          
          # Remove leading space from the converted_paths string
          converted_paths="${converted_paths:1}"
          
          # Set the converted_paths string as the value in changed_packages_paths
          echo "changed_packages_paths=$converted_paths" >> "$GITHUB_OUTPUT"
          echo "changed_packages_paths=$converted_paths" >> "$GITHUB_ENV"
          # Extract base names from paths and join them with a space

      - name: Ensure ROS Package Versions
        id: ensure-version
        run: |
          git config --global user.email "civ-ci@civrobotics.com"
          git config --global user.name "Your Civ-ci"

          # Check if the "fallback-manifest.txt" file exists
          if [ -f "fallback-manifest.txt" ]; then
            # Determine the major and minor version numbers based on the content of "fallback-manifest.txt"
            FALLBACK_MANIFEST=$(cat "fallback-manifest.txt")
            if [[ "$FALLBACK_MANIFEST" == "develop" ]]; then
              MAJOR=0
              MINOR=0
            elif [[ "$FALLBACK_MANIFEST" =~ ^v([0-9]+)\.([0-9]+)$ ]]; then
              MAJOR=${BASH_REMATCH[1]}
              MINOR=${BASH_REMATCH[2]}
            else
              echo "Invalid fallback-manifest: $FALLBACK_MANIFEST"
              exit 1
            fi
            echo "Setting major and minor versions to: $MAJOR.$MINOR"
            echo "major_minor=${MAJOR}.${MINOR}" >> $GITHUB_OUTPUT

            # Loop over each package.xml in the workspace
            for xml_path in $(find . -type f -name "package.xml"); do
              echo "--------------------------------------------------"
              echo "Found package.xml at: $xml_path"
              echo "Contents of the package.xml before update:"
              cat "$xml_path"

              # Update the version to match the parsed major and minor versions
              sed -E -i "s/<version>([0-9]+)\.([0-9]+)\.([0-9]+)<\/version>/<version>${MAJOR}.${MINOR}.0<\/version>/" "$xml_path"

              echo "Contents of the package.xml after update:"
              cat "$xml_path"
            done

            # Only commit and push if there are changes
            if [[ -n $(git status -s) ]]; then
              git add .
              git commit -m "Update package.xml with release version [skip ci]"
              git push
            else
              echo "No changes to commit in repository: $repo_name"
            fi
          else
            echo "Can't find fallback-manifest.txt in repository: $repo_name"
          fi

      - name: Set Packages versions
        id: packages-versions
        if: ${{ env.changed_packages_paths != '' }}
        run: |
          echo "before setting versions starts"
          # Check if the "fallback-manifest.txt" file exists
          if [ -f "fallback-manifest.txt" ]; then
            # Determine the major and minor version numbers based on the content of "fallback-manifest.txt"
            FALLBACK_MANIFEST=$(cat "fallback-manifest.txt")
          fi
          # Derive package names from changed_packages_paths
          IFS=' ' read -ra paths_array <<< "$changed_packages_paths"
          package_names=()
          for path in "${paths_array[@]}"; do
              package_name=$(basename "$path")
              package_names+=("$package_name")
          done
          touch packages_meta_data.txt
          echo "List of packages: ${package_names[@]}"
          for package_name in "${package_names[@]}"; do
            # Convert package name to desired format
            transformed_name="ros-$ROS_DIST-$(echo "$package_name" | tr '_' '-')"
            echo "transformed_name: $transformed_name"
            # Fetch the latest version of the package from Artifactory
            echo "Fetching version for $transformed_name"

            if [[ $FALLBACK_MANIFEST =~ ^v[0-9]+\.[0-9]+$ ]]; then
              MAJOR_MINOR="${FALLBACK_MANIFEST#v}"
              latest_version_output=$(jf rt s "civros-unstable/$ROS_DIST/${transformed_name}/*/*$MAJOR_MINOR.*" --sort-by "created" --sort-order "desc" --limit 1 | jq -r '.[0].path' | grep -o "[0-9]\+\.[0-9]\+\.[0-9]\+" | head -n 1)
            else
              latest_version_output=$(jf rt s "civros-unstable/$ROS_DIST/${transformed_name}/*/*0.0.*" --sort-by "created" --sort-order "desc" --limit 1 | jq -r '.[0].path' | grep -o "[0-9]\+\.[0-9]\+\.[0-9]\+" | head -n 1)
            fi

            echo "Output from Artifactory for $transformed_name:"
            echo "$latest_version_output"
            if [[ -z "$latest_version_output" ]]; then
              echo "No version was found for $transformed_name. Setting patch number to 1."
              patch=1
            else
              # Extract patch
              patch=$(echo "$latest_version_output" | cut -d'.' -f3)

              echo "Patch: $patch"
              # Increment the patch version
              patch=$((patch+1))
              echo "New patch: $patch"
            fi
            echo "New version for $transformed_name: $patch"
            # Write the new package mapping and version to the file
            echo "${transformed_name}=$patch" >> packages_meta_data.txt
          done
          cat packages_meta_data.txt
          echo "after setting versions"

      - name: Upload packages meta data file
        uses: actions/upload-artifact@v3
        with:
          name: packages-meta-data
          path: packages_meta_data.txt

      - name: Configure AWS credentials
        if: ${{ github.event_name == 'push' && env.changed_packages_paths != '' || github.event_name == 'workflow_dispatch' && (steps.manual-input.outputs.label-arm == '' || steps.manual-input.outputs.label-amd == '') }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.CI_AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.CI_AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Start AMD runner
        if: ${{ github.event_name == 'push' && env.changed_packages_paths != '' || github.event_name == 'workflow_dispatch' && (steps.manual-input.outputs.label-arm == '' || steps.manual-input.outputs.label-amd == '') }}
        id: start-amd-runner
        uses: Amir-civ/ec2-github-runner@v2
        with:
          mode: start
          github-token: ${{ secrets.gh_token }}
          ec2-image-id: ami-03b8aec6cd5a3cbed
          ec2-instance-type: c5.2xlarge
          subnet-id: subnet-0ea80778fd45e76a0
          security-group-id: sg-095940a96979f1b1d
          runnerUser: ubuntu

      - name: Start ARM runner
        if: ${{ github.event_name == 'push' && env.changed_packages_paths != '' || github.event_name == 'workflow_dispatch' && (steps.manual-input.outputs.label-arm == '' || steps.manual-input.outputs.label-amd == '') }}
        id: start-arm-runner
        uses: Amir-civ/ec2-github-runner@v2
        with:
          mode: start
          github-token: ${{ secrets.gh_token }}
          ec2-image-id: ami-0663923f594e144cb
          ec2-instance-type: c6g.2xlarge
          subnet-id: subnet-0ea80778fd45e76a0
          security-group-id: sg-095940a96979f1b1d
          runnerUser: ubuntu

      - name: Set Runners Matrix
        id: runners-matrix
        run: |
          RUNNERS_MATRIX="{\"include\":[{\"name\":\"arm-build\",\"label\":\"${{ steps.start-arm-runner.outputs.label || steps.manual-input.outputs.label-arm }}\"},{\"name\":\"amd-build\",\"label\":\"${{ steps.start-amd-runner.outputs.label || steps.manual-input.outputs.label-amd }}\"}]}"
          echo "runners_matrix=${RUNNERS_MATRIX}" >> $GITHUB_OUTPUT
  
  build:
    strategy:
      matrix: ${{fromJson(needs.initiate-workflow.outputs.runners_matrix)}}    
    name: ${{ matrix.name }}
    needs: initiate-workflow 
    if: needs.initiate-workflow.outputs.changed_packages_paths != ''
    runs-on: ${{ matrix.label }}
    timeout-minutes: 20
    env:
      promote-tag: ${{needs.initiate-workflow.outputs.promote-tag}}
      changed_packages_paths: ${{needs.initiate-workflow.outputs.changed_packages_paths}}
      deb_directory: "${{ github.workspace }}/debian_packages"
    steps:
      - name: Disable unattended-upgrades
        run: |
          sudo apt remove -y unattended-upgrades
          pip3 install witmotion
          sudo apt-get install -y tree
          
      - name: checkout
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: additional env installations
        if: ${{ github.event_name != 'workflow_dispatch' }}
        run: |
          sudo ln -s /usr/include/eigen3/Eigen /usr/include/Eigen
          
      - name: Download packages meta data file
        uses: actions/download-artifact@v3
        with:
          name: packages-meta-data

      - name: organizing build order for packages
        run: |
          source /opt/ros/$ROS_DIST/setup.bash
          
          # Run colcon list --topological-order command and extract the first fraction from each line
          build_order=$(colcon list --topological-order | awk '{print $1}')
          #convert strings into arrays
          build_order_arry=($build_order)
          packages_paths_arry=($changed_packages_paths)
          # Create an array to hold the sorted list
          declare -a sorted_packages_paths
          sorted_packages_names=""
          for package in "${!build_order_arry[@]}"; do
            for package_path in "${packages_paths_arry[@]}"; do
                if [[ ${build_order_arry[$package]} = $(basename "$package_path") ]]; then
                sorted_packages_paths+=("$package_path")
                sorted_packages_names+="$(basename "$package_path") "
                fi
            done
          done
          # Remove the trailing space
          sorted_packages_names=${sorted_packages_names::-1}
          echo "soreted packages paths: ${sorted_packages_paths[*]}"
          echo "sorted_packages_paths=${sorted_packages_paths[*]}" >> $GITHUB_ENV
          echo "soreted packages names: ${sorted_packages_names[*]}"
          echo "sorted_packages_names=${sorted_packages_names}" >> $GITHUB_ENV

      - name: Update artifactory server
        run: |
          # Read the fallback branch from the text file
          fallback_branch=$(cat fallback-manifest.txt)
          declare -A branch_priority_map
          branch_priority_map["$BRANCH"]=1001
          # Check if the fallback branch is different from the current branch
          if [[ "$BRANCH" != "$fallback_branch" ]]; then
            branch_priority_map["$fallback_branch"]=1000
          fi
          # Loop through branches and update files
          for branch in "${!branch_priority_map[@]}"; do
            priority="${branch_priority_map[$branch]}"
          pref_file="/etc/apt/preferences.d/10-civ.pref"
          # Create the file if it doesn't exist
          sudo touch "$pref_file"
            # Check if the branch preference already exists
            if ! grep -q "Pin: release c='$branch'" "$pref_file"; then
              sudo bash -c "cat >> $pref_file << EOF
          Package: *
          Pin: release c=$branch
          Pin-Priority: $priority
          
          EOF"
            fi
            source_file="/etc/apt/sources.list.d/civ.list"
            # Create the file if it doesn't exist
            sudo touch "$source_file"
            # Check if the source list for the branch already exists
            source_entry="deb https://amir_b:$ARTIFACTORY_TOKEN@$ARTIFACTORY_URL $ROS_DIST $branch"
            if ! grep -q "$source_entry" "$source_file"; then
              sudo sh -c "echo '$source_entry' >> $source_file"
            fi
          done
          sudo cat /etc/apt/preferences.d/10-civ.pref
          sudo cat /etc/apt/sources.list.d/civ.list
          wget -O civrobotics.pub https://amir_b:$ARTIFACTORY_TOKEN@civrobotics.jfrog.io/artifactory/api/security/keypair/debianKeys/public
          gpg --import civrobotics.pub
          gpg --list-keys
          sudo apt-key add civrobotics.pub
          sudo apt update
          # downloading rosdep mapping file
          sudo curl -u "Amir-civ:$GH_TOKEN" -L $ROSDEP_MAP_FILE -o /etc/ros/rosdep/sources.list.d/local.yaml
          if [ $? -eq 0 ]; then
            echo "YAML file downloaded successfully!"
          else
            echo "Failed to download YAML file."
          fi
          sudo sh -c 'echo "yaml file:///etc/ros/rosdep/sources.list.d/local.yaml" >> /etc/ros/rosdep/sources.list.d/20-default.list'
          
      - name: Build deb package
        id: build_deb_package
        run: |
          major_minor=${{ needs.initiate-workflow.outputs.major_minor }}
          echo "$major_minor"
          # Define the lock file handling function
          handle_lock_files() {
            echo "About to enter lock file handling loop..."
            count=0
            while [ -e "/var/lib/dpkg/lock-frontend" ] || [ -e "/var/lib/dpkg/lock" ]; do
              echo "Inside the lock file handling loop..."
              if sudo fuser /var/lib/dpkg/lock-frontend /var/lib/dpkg/lock >/dev/null 2>&1 || pgrep -f 'apt|dpkg' >/dev/null 2>&1; then
                echo "Active package management processes found. Will not remove lock files(${count}/30 sec's):"
                fuser -v /var/lib/dpkg/lock-frontend /var/lib/dpkg/lock
                if [ $count -ge 30 ]; then
                  echo "Package management processes active for 30 sec, breaking the loop!"
                  break
                fi
                count=$((count + 1))
                sleep 1
              else
                echo "No active or background package management processes found. Force removing lock files..."
                sudo rm -f /var/lib/dpkg/lock-frontend
                sudo rm -f /var/lib/dpkg/lock
                echo "Exit code for removing lock-frontend: $?"
                break
              fi
            done
          }
          # Use colcon to build all identified ROS packages
          sudo apt-get install -y tree
          rosdep update --include-eol-distros
          source /opt/ros/$ROS_DIST/setup.bash
          handle_lock_files
          # sudo su ubuntu -c "bash -c 'cd $(pwd) && rosdep install --from-paths . -r -y'"
          rosdep install --from-paths . -r -y
          # rosdep install --from-paths $(echo $sorted_packages_paths | tr ' ' '\n') -r -y
          colcon build --packages-select $sorted_packages_names
          ls install
          tree install
          built_packages=true
          mkdir -p $deb_directory
          
          IFS=' ' read -ra packages_paths <<< "$sorted_packages_paths"
          for package_path in "${packages_paths[@]}"; do
            cd "$package_path"
            package_src_name=$(basename "$package_path" )
            package_name=$(basename "$package_path" | tr '_' '-')
            package_name="ros-$ROS_DIST-$package_name"

            # Create an associative array to hold the package name and its version
            declare -A package_versions
            meta_data_file="${GITHUB_WORKSPACE}/packages_meta_data.txt"
            # Read the meta_data_file and populate the package_versions array
            while IFS='=' read -r key value; do
              package_versions["$key"]="$value"
            done < ${meta_data_file}

            sed -E -i "s/<version>([0-9]+)\.([0-9]+)\.([0-9]+)<\/version>/<version>$major_minor.${package_versions[$package_name]}<\/version>/" package.xml

            package_version=$(grep '<version>' package.xml | sed 's/.*<version>\(.*\)<\/version>.*/\1/')
            arch=$(dpkg --print-architecture)
            debian_package_name="${package_name}_${package_version}_0focal_${arch}"
            # Extract the keys for the current package using rosdep
            keys=$(rosdep keys --from-paths .)
            # Loop through each key and resolve its dependency
            dep_list=()
            for key in $keys; do
                echo "Resolving key: $key"
                rosdep_output=$(rosdep resolve ${key} --rosdistro=${ROS_DIST} --os=ubuntu:focal)
                echo "Rosdep output for $key: $rosdep_output"
                resolved_dep=$(echo "$rosdep_output" | grep '^#apt' -A1 | tail -n1 | xargs)
                echo "Resolved dependency: $resolved_dep"
                if [[ ! -z "$resolved_dep" && ! " ${dep_list[*]} " =~ " ${resolved_dep} " ]]; then
                    dep_list+=($resolved_dep)
                fi
            done

            # Convert the dep_list array into a comma-separated string
            formatted_deps=$(echo "${dep_list[@]}" | sed 's/ /, /g')
            # Print the result
            echo "Resolved Dependencies for Debian Control File:"
            echo "$formatted_deps"
            echo "dep: ${dep_list[@]}"
            mkdir -p ${debian_package_name}/DEBIAN
            mkdir -p ${debian_package_name}/opt/ros/$ROS_DIST/
            # Populate Package Structure
            if [ -d "$GITHUB_WORKSPACE/install/${package_src_name}/share" ]; then
              mkdir -p ${debian_package_name}/opt/ros/$ROS_DIST/share/
              cp -R $GITHUB_WORKSPACE/install/${package_src_name}/share/* ${debian_package_name}/opt/ros/$ROS_DIST/share/
            else
              echo "Directory install/${package_src_name}/share does not exist."
            fi
            if [ -d "$GITHUB_WORKSPACE/install/${package_src_name}/lib" ]; then
              mkdir -p ${debian_package_name}/opt/ros/$ROS_DIST/lib/
              cp -R $GITHUB_WORKSPACE/install/${package_src_name}/lib/* ${debian_package_name}/opt/ros/$ROS_DIST/lib/
            else
              echo "Directory install/${package_src_name}/lib does not exist."
            fi
            if [ -d "$GITHUB_WORKSPACE/install/${package_src_name}/include" ]; then
              mkdir -p ${debian_package_name}/opt/ros/$ROS_DIST/include/
              cp -R $GITHUB_WORKSPACE/install/${package_src_name}/include/* ${debian_package_name}/opt/ros/$ROS_DIST/include/
            else
              echo "Directory install/${package_src_name}/include does not exist."
            fi
            # Create DEBIAN control file
            {
              echo "Package: $package_name"
              echo "Version: $package_version-0focal"
              echo "Architecture: $arch"
              echo "Maintainer: Civrobotics <civ@civrobotics.com>"
              echo "Depends: $formatted_deps"
              echo "Description: $package_name ROS package"
            } > ${debian_package_name}/DEBIAN/control
            # Display DEBIAN/control file to verify its contents
            cat ${debian_package_name}/DEBIAN/control
            # Build Debian Package
            tree ${debian_package_name}
            handle_lock_files
            dpkg-deb --build ${debian_package_name}
            dpkg-deb -c ${debian_package_name}.deb
            pwd
            ls -al
            echo "Moving .deb from $(pwd)/${debian_package_name}.deb to $deb_directory/"
            mv $(pwd)/${debian_package_name}.deb $deb_directory/
          done
          echo "debs: $deb_directory"
          cd $deb_directory
          pwd
          ls
          # Check for built packages
          cd $deb_directory
          if ! ls *.deb 1>/dev/null 2>&1; then
            built_packages=false
          fi
          echo "built_packages=$built_packages" >> $GITHUB_ENV

      - name: Push to artifactory server
        if: ${{ env.built_packages == 'true' }}
        run: |
          cd $deb_directory
          # Load the package meta data file into a variable
          meta_data_file="${GITHUB_WORKSPACE}/packages_meta_data.txt"
          PACKS=($(ls ${1:-.}/*.deb))
          echo "$PACKS"
          for pack in "${PACKS[@]}"
          do
            name=$(basename "$pack")
            printf "\nPublishing %s\n" "$name"
            
            dirname=$(cut -d '_' -f1 <<< "$name")

            #push them to Artifactory
            curl --fail -uamir_b:$ARTIFACTORY_TOKEN -XPUT "https://$ARTIFACTORY_URL/$ROS_DIST/${dirname}/${BRANCH}/${name};deb.distribution=$ROS_DIST;deb.component=$BRANCH;deb.architecture=$(dpkg --print-architecture);deb.build_number=$BUILD_NUMBER;deb.repo=$REPO;deb.commit_sha=$GITHUB_SHA;" -T $pack -o $dirname.json
            cat $dirname.json
          done

      - name: Update rosdep yaml file
        if: ${{ env.built_packages == 'true' }}
        run: |
          export HOME=/home/ubuntu
          git clone https://"Amir-civ:$GH_TOKEN"@github.com/Civdrone/scripts.git
          cd scripts
          git checkout ci-github-actions
          IFS=' ' read -ra packages_paths <<< "$changed_packages_paths"
          for package_path in "${packages_paths[@]}"; do
            # Check if package path is root
            if [[ $package_path == "." ]]; then
              package_name=$REPO
            else
              package_name=$(basename "$package_path")
            fi
      
            package_exists=$(yq ".$package_name" ./docker_container/local.yaml)
            if [[ $package_exists = null ]]; then
              # Define the apt package
              apt_package=$(echo "$package_name" | sed 's/_/-/g; s/^/ros-$ROS_DIST-/')
              
              # Create the YAML content for the new package
              new_yaml_content="${package_name}:\n  ubuntu:\n    focal: [${apt_package}]"
              
              # Read the existing YAML content from the file
              existing_yaml_content=$(sudo cat ./docker_container/local.yaml)
              
              # Append the new package information to the existing YAML content
              yaml_content="${existing_yaml_content}\n${new_yaml_content}"
              
              # Write the modified YAML content to the file
              echo -e "${yaml_content}" > ./docker_container/local.yaml
              # Push changes to remote
              git config --global user.email "amir@civrobotics.com"
              git config --global user.name "amir-ci"
              git add .
              git commit -m "changed rosdep yaml file from ci, owner/repo: ${REPO}, branch: ${BRANCH}  build number: ${BUILD_NUMBER}."
              git push origin ci-github-actions
            else
              echo "$package_name exists"
            fi
          done

      - name: Update commit status and cencel all workflows with the same branch on failure
        if: ${{ failure() }}
        run: |
          if [[ $BRANCH =~ ^v[0-9]+\.[0-9]+$ ]]; then
            sudo curl -u "Amir-civ:$GH_TOKEN" -L https://raw.githubusercontent.com/$REPO_OWNER/civros-release/$BRANCH/repo.csv -o ./repo.csv
          else
            sudo curl -u "Amir-civ:$GH_TOKEN" -L https://raw.githubusercontent.com/$REPO_OWNER/civros-release/develop/repo.csv -o ./repo.csv
          fi
          
          if [ $? -eq 0 ]; then
              echo "repo.csv file downloaded successfully!"
          else
              echo "Failed to download repo.csv file."
          fi
          # Read the CSV file and cencel repositories
          while IFS=, read -r repo || [ -n "$repo" ]; do
            # Get the most recent workflow run ID for the specified event and branch
            run_id=$(curl -s -H "Authorization: Bearer $GH_TOKEN" \
            "https://api.github.com/repos/$REPO_OWNER/$repo/actions/runs?branch=$BRANCH" \
            | jq -r '.workflow_runs[0].id')
            # Cancel the workflow run if a run ID is found
            if [ "$run_id" != "null" ]; then
                curl -X POST -s -H "Authorization: Bearer $GH_TOKEN" \
                "https://api.github.com/repos/$REPO_OWNER/$repo/actions/runs/$run_id/cancel"
                echo "Workflow run $run_id has been canceled"
            else
                echo "No workflow run found for $repo"
            fi
          done < ./repo.csv
          # update commit status
          curl -X POST -H "Authorization: token $GH_TOKEN" -H "Accept: application/vnd.github.v3+json" https://api.github.com/repos/$REPO_OWNER/$REPO/statuses/${COMMIT_ID} -d '{"state": "failure", "context": "continuous-integration/build-${BUILD_NUMBER"}'

      - name: Discard Local Changes
        if: ${{ always() }}
        run: |
          cd $GITHUB_WORKSPACE
          git checkout -- .
          git clean -f
        
  stop-runners:
    needs: [initiate-workflow, build]
    runs-on: ubuntu-20.04
    timeout-minutes: 20
    if: always() && (needs.initiate-workflow.outputs.label-amd != null || needs.initiate-workflow.outputs.label-arm != null)
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.CI_AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.CI_AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Stop AMD runner
        uses: Amir-civ/ec2-github-runner@v2
        with:
          mode: stop
          github-token: ${{ secrets.gh_token }}
          label: ${{ needs.initiate-workflow.outputs.label-amd }}
          ec2-instance-id: ${{ needs.initiate-workflow.outputs.amd-instance-id }}

      - name: Stop ARM runner
        uses: Amir-civ/ec2-github-runner@v2
        with:
          mode: stop
          github-token: ${{ secrets.gh_token }}
          label: ${{ needs.initiate-workflow.outputs.label-arm }}
          ec2-instance-id: ${{ needs.initiate-workflow.outputs.arm-instance-id }}