name: ci-new-design

on:
  workflow_dispatch:
    inputs:
      packages_build_paths:
        description: 'intput packages paths to build seperated by spaces'
        required: true
        default: ''
      runner_amd_lable:
        description: 'aws self hosted runner amd lable to run jobs '
        required: true
        default: ''
      runner_arm_lable:
        description: 'aws self hosted runner arm lable to run jobs '
        required: true
        default: ''
      runner_arm_id:
        description: 'aws self hosted runner arm id to run jobs '
        required: true
        default: ''
      runner_amd_id:
        description: 'aws self hosted runner amd id to run jobs '
        required: true
        default: ''
  push:
    # branches-ignore:
      # - 'v[0-9]+.[0-9]+'
  pull_request:
    branches:
      - develop
      - 'v[0-9]+.[0-9]+'
          
concurrency: lock-${{ github.ref }}

env:
  WORKSPACE_PATH: ${{ github.workspace }}
  COMMIT_ID: ${{ github.sha }}
  BUILD_NUMBER: ${{ github.run_number }}
  BRANCH: ${{ github.ref_name }}
  REPO_OWNER: ${{ github.repository_owner }}
  REPO: ${{ github.event.repository.name }}
  ROSDEP_MAP_FILE: ${{ secrets.rosdep_map_file }}
  ARTIFACTORY_TOKEN: ${{ secrets.artifactory_token }}
  ARTIFACTORY_URL: civrobotics.jfrog.io/artifactory/civros-unstable
  GH_TOKEN: ${{ secrets.gh_token }}
  AWS_REGION: us-east-1

jobs:
  initiate-workflow:
    runs-on: ubuntu-20.04
    outputs:
      label-arm: ${{ steps.start-arm-runner.outputs.label || steps.manual-input.outputs.label-arm }}
      arm-instance-id: ${{ steps.start-arm-runner.outputs.ec2-instance-id || steps.manual-input.outputs.ec2-instance-id-arm }}
      label-amd: ${{ steps.start-amd-runner.outputs.label || steps.manual-input.outputs.label-amd }}
      amd-instance-id: ${{ steps.start-amd-runner.outputs.ec2-instance-id || steps.manual-input.outputs.ec2-instance-id-amd }}
      promote-tag: ${{ steps.promote-tag.outputs.PROMOTED_TAG }}
      changed_packages_paths: ${{ steps.manual-input.outputs.changed_packages_paths || steps.changed-packages.outputs.changed_packages_paths }}
    steps:
      - name: checkout
        if: ${{ !contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') }}
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          
      - name: Check release promoteted tag
        id: promote-tag
        if: contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$')
        run: |
          # Run the command to check if the full build tag exists in civros-release
          PROMOTED_TAG=$(git ls-remote --refs --tags https://github.com/Civdrone/civros-release.git "${BRANCH}-promoted" | awk '{print $2}' | sed 's/refs\/tags\///')
          if [ -z "$PROMOTED_TAG" ]; then
            echo "PROMOTED_TAG variable is empty"
            exit 1
          else
            echo "TAG variable is not empty, value is: $PROMOTED_TAG"
            echo "PROMOTED_TAG=true" >> "$GITHUB_OUTPUT"
            echo "PROMOTED_TAG=true" >> "$GITHUB_ENV"
          fi

      - name: Get unique changed packages
        id: changed-packages
        ## checks if trigger on push event, on release branch also checks for full build tag
        if: ${{ github.event_name == 'push' && !contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') || contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') && env.PROMOTED_TAG == 'true' && github.event_name == 'push' }}
        run: |
          mapfile -t CHANGED_FILES < <(git diff --name-only ${{ github.event.before }} ${{ github.event.after }})
          # Initialize unique_packages_paths
          unique_packages_paths=()

          for path in "${CHANGED_FILES[@]}"; do
            # if the path is a hidden directory or file, skip to the next iteration
            if [[ $path == .* ]]; then
              continue
            fi
            current_dirname="$(realpath "$path")"
            has_package_xml=false
            while [[ "$current_dirname" != "${GITHUB_WORKSPACE}" && $has_package_xml == false ]]; do
              current_dirname=$(dirname "$current_dirname")
              if [[ -f "${current_dirname}/package.xml" ]]; then
                has_package_xml=true
              fi
            done

            # Add if package.xml was found
            if [[ $has_package_xml == true ]]; then
              # change working directory of hosted runner to self hosted runner
              current_dirname="${current_dirname/\/home\/runner\/work/\/actions-runner\/_work}"
              unique_packages_paths+=("$current_dirname")
            fi
          done

          # Remove duplicates from the unique_packages_paths list
          unique_packages_paths=($(for path in "${unique_packages_paths[@]}"; do
            echo "$path"
          done | sort -u))

          # Output the list of unique packages paths
          echo "Changed packages: ${unique_packages_paths[@]}"

          if [[ ${#unique_packages_paths[@]} -eq 0 ]]; then
              echo "The unique_packages_paths array is empty. Exiting the script."
              exit 1
          fi

          # Set the `changed_packages_paths` environment variable with the list of unique packages paths
          echo "changed_packages_paths=${unique_packages_paths[*]}" >> "$GITHUB_OUTPUT"

      - name: Get workflow manual input
        id: manual-input
        ## checks if trigger on dispatch event, on release branch also checks for full build tag
        if: ${{ github.event_name == 'workflow_dispatch' && !contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') || contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') && env.PROMOTED_TAG == 'true' && github.event_name == 'workflow_dispatch' }}
        run: |
          # Split the input paths by spaces and store them in an array
          echo "paths: ${{ github.event.inputs.packages_build_paths }}"
          echo "arm lable: ${{ github.event.inputs.runner_arm_lable }}"
          echo "arm id: ${{ github.event.inputs.runner_arm_id }}"
          echo "amd lable: ${{ github.event.inputs.runner_amd_lable }}"
          echo "amd id: ${{ github.event.inputs.runner_amd_id }}"

          IFS=' ' read -ra paths <<< "${{ github.event.inputs.packages_build_paths }}"

          # Initialize an empty string to store the converted absolute paths
          converted_paths=""
          
          # Iterate over the paths array and convert each path to an absolute path using realpath
          for path in "${paths[@]}"; do
            absolute_path=$(realpath "$path")
            # change working directory of hosted runner to self hosted runner
            absolute_path="${absolute_path/\/home\/runner\/work/\/actions-runner\/_work}"
            converted_paths+=" $absolute_path"
          done
          
          # Remove leading space from the converted_paths string
          converted_paths="${converted_paths:1}"
          
          # Set the converted_paths string as the value in changed_packages_paths
          echo "changed_packages_paths=$converted_paths" >> "$GITHUB_OUTPUT"
          echo "label-arm=${{ github.event.inputs.runner_arm_lable }}" >> "$GITHUB_OUTPUT"
          echo "label-amd=${{ github.event.inputs.runner_amd_lable }}" >> "$GITHUB_OUTPUT"
          echo "ec2-instance-id-arm=${{ github.event.inputs.runner_arm_id }}" >> "$GITHUB_OUTPUT"
          echo "ec2-instance-id-amd=${{ github.event.inputs.runner_amd_id }}" >> "$GITHUB_OUTPUT"

      - name: Configure AWS credentials
        if: ${{ github.event_name != 'workflow_dispatch' }}
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.CI_AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.CI_AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Start AMD runner
        if: ${{ github.event_name != 'workflow_dispatch' }}
        id: start-amd-runner
        uses: Amir-civ/ec2-github-runner@main
        with:
          mode: start
          github-token: ${{ secrets.gh_token }}
          ec2-image-id: ami-0f77e5cbaa4a9986e
          ec2-instance-type: c5.2xlarge
          subnet-id: subnet-0ea80778fd45e76a0
          security-group-id: sg-095940a96979f1b1d

      - name: Start ARM runner
        if: ${{ github.event_name != 'workflow_dispatch' }}
        id: start-arm-runner
        uses: Amir-civ/ec2-github-runner@main
        with:
          mode: start
          github-token: ${{ secrets.gh_token }}
          ec2-image-id: ami-015d7058735bcca56
          ec2-instance-type: c6g.2xlarge
          subnet-id: subnet-0ea80778fd45e76a0
          security-group-id: sg-095940a96979f1b1d

  arm_build:
    needs: initiate-workflow # required to start the main job when the runner is ready
    if: needs.initiate-workflow.outputs.changed_packages_paths != ''
    runs-on: ${{ needs.initiate-workflow.outputs.label-arm }} # run the job on the newly created runner
    env:  # Set the environment variables at the job level
      promote-tag: ${{needs.initiate-workflow.outputs.promote-tag}}
      changed_packages_paths: ${{needs.initiate-workflow.outputs.changed_packages_paths}}
    steps:
      - name: checkout
        if: ${{ !contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') }}
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Hello arm
        run: |
          echo "$promote-tag $changed_packages_paths"
      - name: additional env installations
        if: ${{ github.event_name != 'workflow_dispatch' }}
        run: |
          sudo ln -s /usr/include/eigen3/Eigen /usr/include/Eigen

      - name: Update artifactory server
        ## checks if changed packages, on release branch also checks for full build tag
        if: ${{ !contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') || contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') && env.FULL_BUILD_TAG == 'true' }}
        run: |
          # Get default branch
          default_branch=$(curl -H "Authorization: token $GH_TOKEN" -s https://api.github.com/repos/$REPO_OWNER/$REPO | jq -r '.default_branch')

          readarray -t branches < <(git show-branch -a | grep '\*' | awk 'match($0, /\[[^]]+\]/) { branch = substr($0, RSTART+1, RLENGTH-2); gsub(/origin\//, "", branch); gsub(/[~^].*/, "", branch); if (!seen[branch]++) print branch; if (branch == "develop" || branch == "main" || branch == "master") exit }' | uniq)

          # Iterate over the branches array until a match is found, then trim the array
          for ((idx=0; idx<${#branches[@]}; idx++)); do
              if [[ "${branches[idx]}" =~ ^v[0-9]+\.[0-9]+$ ]] || [[ "${branches[idx]}" == "$default_branch" ]]; then
                  branches=("${branches[@]:0:idx+1}")
                  break
              fi
          done

          priority=1001
          
          for branch in "${branches[@]}"; do
              sudo bash -c "cat >> /etc/apt/preferences.d/10-civ.pref << EOF
          Package: *
          Pin: release c='$branch'
          Pin-Priority: $priority
          
          EOF"
              priority=$((priority - 1))
              sudo sh -c "echo 'deb https://amir_b:$ARTIFACTORY_TOKEN@$ARTIFACTORY_URL galactic $branch' >> /etc/apt/sources.list.d/civ.list"
          done
          
          sudo cat /etc/apt/preferences.d/10-civ.pref
          sudo cat /etc/apt/sources.list.d/civ.list
          wget -O civrobotics.pub https://amir_b:$ARTIFACTORY_TOKEN@civrobotics.jfrog.io/artifactory/api/security/keypair/debianKeys/public
          gpg --import civrobotics.pub
          gpg --list-keys
          sudo apt-key add civrobotics.pub
          sudo apt update
          # downloading rosdep mapping file
          sudo curl -u "Amir-civ:$GH_TOKEN" -L $ROSDEP_MAP_FILE -o /etc/ros/rosdep/sources.list.d/local.yaml
          if [ $? -eq 0 ]; then
            echo "YAML file downloaded successfully!"
          else
            echo "Failed to download YAML file."
          fi
          sudo sh -c 'echo "yaml file:///etc/ros/rosdep/sources.list.d/local.yaml" >> /etc/ros/rosdep/sources.list.d/20-default.list'

      - name: Build deb package
        ## checks if changed packages, on release branch also checks for full build tag
        # if: ${{ !contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') || contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') && env.FULL_BUILD_TAG == 'true' }}
        id: build_deb_package
        run: |
          built_packages=true
          IFS=' ' read -ra packages_paths <<< "$changed_packages_paths"
          for package_path in "${packages_paths[@]}"; do
            pwd
            ls
            cd "$package_path"
            pwd
            ls
            sed -E -i "s/<version>([0-9]+)\.([0-9]+)\.([0-9]+)<\/version>/<version>\1.\2.${BUILD_NUMBER}<\/version>/" package.xml
            source /opt/ros/galactic/setup.bash
            rosdep update --include-eol-distros
            bloom-generate rosdebian
            sudo apt update
            sudo apt build-dep . -y
            dpkg-buildpackage -b -rfakeroot -us -uc
            cd ..
            # ls | grep .deb
            if ! ls *.deb 1>/dev/null 2>&1; then
              built_packages=false
            fi
          done
          echo "built_packages=$built_packages" >> $GITHUB_ENV

      - name: Push to artifactory server
        ## checks if changed packages & built packages, on release branch also checks for full build tag
        if: ${{ env.built_packages == 'true' && !contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') || contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') && env.FULL_BUILD_TAG == 'true' && env.built_packages == 'true' }}
        run: |
          # convert the list to an array
          IFS=' ' read -ra changed_packages_paths_arry <<< "$changed_packages_paths"

          # use an associative array(bash dictionary) to handle duplicates
          declare -A debian_packages_paths

          # loop over each path, get the dirname and add it to the associative array(bash dictionary)
          for i in "${changed_packages_paths_arry[@]}"; do
            dirname=$(dirname "$i")
            debian_packages_paths["$dirname"]=1
          done

          # now debian_packages_paths is a list with unique directories, so we can iterate over it
          for dir in "${!debian_packages_paths[@]}"; do
            echo "Processing directory $dir"
            cd "$dir"
            
            # your script comes here
            PACKS=($(ls ${1:-.}/*.deb))
            echo "$PACKS"
            for pack in "${PACKS[@]}"
            do
                name=$(basename "$pack")
                printf "\nPublishing %s\n" "$name"
                
                dirname=$(cut -d '_' -f1 <<< "$name")
                #push them to Artifactory
                curl --fail -uamir_b:$ARTIFACTORY_TOKEN -XPUT "https://$ARTIFACTORY_URL/galactic/${dirname}/${BRANCH}/${name};deb.distribution=galactic;deb.component=$BRANCH;deb.architecture=$(dpkg --print-architecture);deb.build_number=$BUILD_NUMBER" -T $pack -o $dirname.json
                cat $dirname.json
            done

            # get back to the initial directory, so that relative paths work in the next iteration
            cd -
          done

      - name: Update rosdep yaml file
        ## checks if changed packages_paths & built packages, on release branch also checks for full build tag
        if: ${{ env.built_packages == 'true' && !contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') || contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') && env.FULL_BUILD_TAG == 'true' && env.built_packages == 'true' }}
        run: |
          git clone https://"Amir-civ:$GH_TOKEN"@github.com/Civdrone/scripts.git
          cd scripts
          git checkout ci-github-actions
          IFS=' ' read -ra packages_paths <<< "$changed_packages_paths"
          for package_path in "${packages_paths[@]}"; do
            # Check if package path is root
            if [[ $package_path == "." ]]; then
              package_name=$REPO
            else
              package_name=$(basename "$package_path")
            fi
      
            package_exists=$(yq ".$package_name" ./docker_container/local.yaml)
            if [[ $package_exists = null ]]; then
              # Define the apt package
              apt_package=$(echo "$package_name" | sed 's/_/-/g; s/^/ros-galactic-/')
              
              # Create the YAML content for the new package
              new_yaml_content="${package_name}:\n  ubuntu:\n    focal: [${apt_package}]"
              
              # Read the existing YAML content from the file
              existing_yaml_content=$(sudo cat ./docker_container/local.yaml)
              
              # Append the new package information to the existing YAML content
              yaml_content="${existing_yaml_content}\n${new_yaml_content}"
              
              # Write the modified YAML content to the file
              echo -e "${yaml_content}" > ./docker_container/local.yaml
              # Push changes to remote
              git config --global user.email "amir@civrobotics.com"
              git config --global user.name "amir-ci"
              git add .
              git commit -m "changed rosdep yaml file from ci, owner/repo: ${REPO}, branch: ${BRANCH}  build number: ${BUILD_NUMBER}."
              git push origin ci-github-actions
            else
              echo "$package_name exists"
            fi
          done       

      - name: Update commit status and cencel all workflows with the same branch on failure
        if: ${{ failure() }}
        run: |
          sudo curl -u "Amir-civ:$GH_TOKEN" -L https://raw.githubusercontent.com/$REPO_OWNER/civros-release/main/repo.csv -o ./repo.csv
          if [ $? -eq 0 ]; then
              echo "repo.csv file downloaded successfully!"
          else
              echo "Failed to download repo.csv file."
          fi
          # Read the CSV file and cencel repositories
          while IFS=, read -r repo || [ -n "$repo" ]; do
            # Get the most recent workflow run ID for the specified branch
            run_id=$(curl -s -H "Authorization: Bearer $GH_TOKEN" \
            "https://api.github.com/repos/$REPO_OWNER/$repo/actions/runs?branch=$BRANCH&event=push" \
            | jq -r '.workflow_runs[0].id')

            # Cancel the workflow run
            curl -X POST -s -H "Authorization: Bearer $GH_TOKEN" \
            "https://api.github.com/repos/$REPO_OWNER/$repo/actions/runs/$run_id/cancel"

            echo "Workflow run $run_id has been canceled"
          done < ./repo.csv
          # update commit status
          curl -X POST -H "Authorization: token $GH_TOKEN" -H "Accept: application/vnd.github.v3+json" https://api.github.com/repos/$REPO_OWNER/$REPO/statuses/${COMMIT_ID} -d '{"state": "failure", "context": "continuous-integration/build-${BUILD_NUMBER"}'

      - name: Discard Local Changes
        if: ${{ always() }}
        run: |
          cd $GITHUB_WORKSPACE
          git checkout -- .
          git clean -f
          
      - name: Post to a Slack channel
        if: ${{ always() }}
        id: slack
        uses: slackapi/slack-github-action@v1.23.0
        with:
          # Slack channel id, channel name, or user id to post message.
          # See also: https://api.slack.com/methods/chat.postMessage#channels
          # You can pass in multiple channels to post to by providing a comma-delimited list of channel IDs.
          channel-id: 'C051SPVTW2Z'
          # For posting a simple plain text message
          slack-message: "GitHub build result: ${{ job.status }}\nWorkflow: ${{ github.job }}\nRepository: ${{ github.event.repository.name }}\nBranch: ${{ github.ref_name }}\nBuild Number: ${{ github.run_number }}\n${{ github.event.pull_request.html_url || github.event.head_commit.url }}"
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}

  amd_build:
    needs: initiate-workflow # required to start the main job when the runner is ready
    if: needs.initiate-workflow.outputs.changed_packages_paths != ''
    runs-on: ${{ needs.initiate-workflow.outputs.label-amd }} # run the job on the newly created runner
    env:  # Set the environment variables at the job level
      promote-tag: ${{needs.initiate-workflow.outputs.promote-tag}}
      changed_packages_paths: ${{needs.initiate-workflow.outputs.changed_packages_paths}}
    
    steps:
      - name: checkout
        if: ${{ !contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') }}
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          
      - name: Hello amd
        run: |
          echo "$promote-tag $changed_packages_paths"

      - name: additional env installations
        if: ${{ github.event_name != 'workflow_dispatch' }}
        run: |
          sudo ln -s /usr/include/eigen3/Eigen /usr/include/Eigen

      - name: Update artifactory server
        ## checks if changed packages, on release branch also checks for full build tag
        if: ${{ !contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') || contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') && env.FULL_BUILD_TAG == 'true' }}
        run: |
          # Get default branch
          default_branch=$(curl -H "Authorization: token $GH_TOKEN" -s https://api.github.com/repos/$REPO_OWNER/$REPO | jq -r '.default_branch')

          readarray -t branches < <(git show-branch -a | grep '\*' | awk 'match($0, /\[[^]]+\]/) { branch = substr($0, RSTART+1, RLENGTH-2); gsub(/origin\//, "", branch); gsub(/[~^].*/, "", branch); if (!seen[branch]++) print branch; if (branch == "develop" || branch == "main" || branch == "master") exit }' | uniq)

          # Iterate over the branches array until a match is found, then trim the array
          for ((idx=0; idx<${#branches[@]}; idx++)); do
              if [[ "${branches[idx]}" =~ ^v[0-9]+\.[0-9]+$ ]] || [[ "${branches[idx]}" == "$default_branch" ]]; then
                  branches=("${branches[@]:0:idx+1}")
                  break
              fi
          done

          priority=1001
          
          for branch in "${branches[@]}"; do
              sudo bash -c "cat >> /etc/apt/preferences.d/10-civ.pref << EOF
          Package: *
          Pin: release c='$branch'
          Pin-Priority: $priority
          
          EOF"
              priority=$((priority - 1))
              sudo sh -c "echo 'deb https://amir_b:$ARTIFACTORY_TOKEN@$ARTIFACTORY_URL galactic $branch' >> /etc/apt/sources.list.d/civ.list"
          done
          
          sudo cat /etc/apt/preferences.d/10-civ.pref
          sudo cat /etc/apt/sources.list.d/civ.list
          wget -O civrobotics.pub https://amir_b:$ARTIFACTORY_TOKEN@civrobotics.jfrog.io/artifactory/api/security/keypair/debianKeys/public
          gpg --import civrobotics.pub
          gpg --list-keys
          sudo apt-key add civrobotics.pub
          sudo apt update
          # downloading rosdep mapping file
          sudo curl -u "Amir-civ:$GH_TOKEN" -L $ROSDEP_MAP_FILE -o /etc/ros/rosdep/sources.list.d/local.yaml
          if [ $? -eq 0 ]; then
            echo "YAML file downloaded successfully!"
          else
            echo "Failed to download YAML file."
          fi
          sudo sh -c 'echo "yaml file:///etc/ros/rosdep/sources.list.d/local.yaml" >> /etc/ros/rosdep/sources.list.d/20-default.list'

      - name: Build deb package
        ## checks if changed packages, on release branch also checks for full build tag
        # if: ${{ !contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') || contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') && env.FULL_BUILD_TAG == 'true' }}
        id: build_deb_package
        run: |
          built_packages=true
          IFS=' ' read -ra packages_paths <<< "$changed_packages_paths"
          for package_path in "${packages_paths[@]}"; do
            pwd
            ls
            cd "$package_path"
            pwd
            ls
            sed -E -i "s/<version>([0-9]+)\.([0-9]+)\.([0-9]+)<\/version>/<version>\1.\2.${BUILD_NUMBER}<\/version>/" package.xml
            source /opt/ros/galactic/setup.bash
            rosdep update --include-eol-distros
            bloom-generate rosdebian
            sudo apt update
            sudo apt build-dep . -y
            dpkg-buildpackage -b -rfakeroot -us -uc
            cd ..
            # ls | grep .deb
            if ! ls *.deb 1>/dev/null 2>&1; then
              built_packages=false
            fi
          done
          echo "built_packages=$built_packages" >> $GITHUB_ENV

      - name: Push to artifactory server
        ## checks if changed packages & built packages, on release branch also checks for full build tag
        if: ${{ env.built_packages == 'true' && !contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') || contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') && env.FULL_BUILD_TAG == 'true' && env.built_packages == 'true' }}
        run: |
          # convert the list to an array
          IFS=' ' read -ra changed_packages_paths_arry <<< "$changed_packages_paths"

          # use an associative array(bash dictionary) to handle duplicates
          declare -A debian_packages_paths

          # loop over each path, get the dirname and add it to the associative array(bash dictionary)
          for i in "${changed_packages_paths_arry[@]}"; do
            dirname=$(dirname "$i")
            debian_packages_paths["$dirname"]=1
          done

          # now debian_packages_paths is a list with unique directories, so we can iterate over it
          for dir in "${!debian_packages_paths[@]}"; do
            echo "Processing directory $dir"
            cd "$dir"
            
            # your script comes here
            PACKS=($(ls ${1:-.}/*.deb))
            echo "$PACKS"
            for pack in "${PACKS[@]}"
            do
                name=$(basename "$pack")
                printf "\nPublishing %s\n" "$name"
                
                dirname=$(cut -d '_' -f1 <<< "$name")
                #push them to Artifactory
                curl --fail -uamir_b:$ARTIFACTORY_TOKEN -XPUT "https://$ARTIFACTORY_URL/galactic/${dirname}/${BRANCH}/${name};deb.distribution=galactic;deb.component=$BRANCH;deb.architecture=$(dpkg --print-architecture);deb.build_number=$BUILD_NUMBER" -T $pack -o $dirname.json
                cat $dirname.json
            done

            # get back to the initial directory, so that relative paths work in the next iteration
            cd -
          done

      - name: Update rosdep yaml file
        ## checks if changed packages_paths & built packages, on release branch also checks for full build tag
        if: ${{ env.built_packages == 'true' && !contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') || contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') && env.FULL_BUILD_TAG == 'true' && env.built_packages == 'true' }}
        run: |
          git clone https://"Amir-civ:$GH_TOKEN"@github.com/Civdrone/scripts.git
          cd scripts
          git checkout ci-github-actions
          IFS=' ' read -ra packages_paths <<< "$changed_packages_paths"
          for package_path in "${packages_paths[@]}"; do
            # Check if package path is root
            if [[ $package_path == "." ]]; then
              package_name=$REPO
            else
              package_name=$(basename "$package_path")
            fi
      
            package_exists=$(yq ".$package_name" ./docker_container/local.yaml)
            if [[ $package_exists = null ]]; then
              # Define the apt package
              apt_package=$(echo "$package_name" | sed 's/_/-/g; s/^/ros-galactic-/')
              
              # Create the YAML content for the new package
              new_yaml_content="${package_name}:\n  ubuntu:\n    focal: [${apt_package}]"
              
              # Read the existing YAML content from the file
              existing_yaml_content=$(sudo cat ./docker_container/local.yaml)
              
              # Append the new package information to the existing YAML content
              yaml_content="${existing_yaml_content}\n${new_yaml_content}"
              
              # Write the modified YAML content to the file
              echo -e "${yaml_content}" > ./docker_container/local.yaml
              # Push changes to remote
              git config --global user.email "amir@civrobotics.com"
              git config --global user.name "amir-ci"
              git add .
              git commit -m "changed rosdep yaml file from ci, owner/repo: ${REPO}, branch: ${BRANCH}  build number: ${BUILD_NUMBER}."
              git push origin ci-github-actions
            else
              echo "$package_name exists"
            fi
          done       

      - name: Update commit status and cencel all workflows with the same branch on failure
        if: ${{ failure() }}
        run: |
          sudo curl -u "Amir-civ:$GH_TOKEN" -L https://raw.githubusercontent.com/$REPO_OWNER/civros-release/main/repo.csv -o ./repo.csv
          if [ $? -eq 0 ]; then
              echo "repo.csv file downloaded successfully!"
          else
              echo "Failed to download repo.csv file."
          fi
          # Read the CSV file and cencel repositories
          while IFS=, read -r repo || [ -n "$repo" ]; do
            # Get the most recent workflow run ID for the specified branch
            run_id=$(curl -s -H "Authorization: Bearer $GH_TOKEN" \
            "https://api.github.com/repos/$REPO_OWNER/$repo/actions/runs?branch=$BRANCH&event=push" \
            | jq -r '.workflow_runs[0].id')

            # Cancel the workflow run
            curl -X POST -s -H "Authorization: Bearer $GH_TOKEN" \
            "https://api.github.com/repos/$REPO_OWNER/$repo/actions/runs/$run_id/cancel"

            echo "Workflow run $run_id has been canceled"
          done < ./repo.csv
          # update commit status
          curl -X POST -H "Authorization: token $GH_TOKEN" -H "Accept: application/vnd.github.v3+json" https://api.github.com/repos/$REPO_OWNER/$REPO/statuses/${COMMIT_ID} -d '{"state": "failure", "context": "continuous-integration/build-${BUILD_NUMBER"}'

      - name: Discard Local Changes
        ## checks if changed packages, on release branch also checks for full build tag
        if: ${{ always() }}
        run: |
          cd $GITHUB_WORKSPACE
          git checkout -- .
          git clean -f
          
      - name: Post to a Slack channel
        if: ${{ always() }}
        id: slack
        uses: slackapi/slack-github-action@v1.23.0
        with:
          # Slack channel id, channel name, or user id to post message.
          # See also: https://api.slack.com/methods/chat.postMessage#channels
          # You can pass in multiple channels to post to by providing a comma-delimited list of channel IDs.
          channel-id: 'C051SPVTW2Z'
          # For posting a simple plain text message
          slack-message: "GitHub build result: ${{ job.status }}\nWorkflow: ${{ github.job }}\nRepository: ${{ github.event.repository.name }}\nBranch: ${{ github.ref_name }}\nBuild Number: ${{ github.run_number }}\n${{ github.event.pull_request.html_url || github.event.head_commit.url }}"
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}

  depends_on_trigger:
    needs: [amd_build, arm_build, initiate-workflow]
    if: ${{ needs.amd_build.result == 'success' && needs.arm_build.result == 'success' }}
    runs-on: ${{ needs.initiate-workflow.outputs.label-amd }} # run the job on the newly created runner
    outputs:
      recursion_ends: ${{ steps.trigger-depends-pacakge.outputs.recursion_ends }}
    env:  # Set the environment variables at the job level
      promote-tag: ${{needs.initiate-workflow.outputs.promote-tag}}
      changed_packages_paths: ${{needs.initiate-workflow.outputs.changed_packages_paths}}
      label_arm: ${{needs.initiate-workflow.outputs.label-arm}}
      label_amd: ${{needs.initiate-workflow.outputs.label-amd}}
      arm_instance_id: ${{needs.initiate-workflow.outputs.arm-instance-id}}
      amd_instance_id: ${{needs.initiate-workflow.outputs.amd-instance-id}}
    steps:
    - name: checkout
      uses: actions/checkout@v3
      with:
        fetch-depth: 0

    - name: Trigger task that depends on packages
      id: trigger-depends-pacakge
      run: |
        echo "Changed package paths: $changed_packages_paths"
        mkdir ros_ws && cd ros_ws
        # Download repo.csv
        sudo curl -u "Amir-civ:$GH_TOKEN" -L https://raw.githubusercontent.com/$REPO_OWNER/civros-release/main/repo.csv -o ./repo.csv
        if [ $? -eq 0 ]; then
            echo "repo.csv file downloaded successfully!"
        else
            echo "Failed to download repo.csv file."
        fi
        
        # Read the CSV file and clone repositories
        while IFS=, read -r repo || [ -n "$repo" ]; do
            git clone https://"$Amir-civ":"${GH_TOKEN}"@github.com/Civdrone/"$repo".git
        done < ./repo.csv
        
        # Source ROS 2 Galactic installation
        source /opt/ros/galactic/setup.bash
        
        # Run colcon list --topological-order command and extract the first fraction from each line
        build_order=$(colcon list --topological-order | awk '{print $1}')
        # IFS=' ' read -ra build_order_arry <<< "$build_order"
        # IFS=' ' read -ra packages_paths_arry <<< "$changed_packages_paths"
        build_order_arry=($build_order)
        packages_paths_arry=($changed_packages_paths)

        for i in "${!build_order_arry[@]}"; do
            for package_path in "${packages_paths_arry[@]}"; do
                if [[ ${build_order_arry[$i]} = $(basename "$package_path") ]]; then
                    next_packages_arry=("${build_order_arry[@]:$((i+1))}")
                    break 2
                fi
            done
        done

        if [[ ${#next_packages_arry[@]} -gt 0 ]]; then
            echo "next package: ${next_packages_arry[0]}"
        else
            echo "No next packages found."
        fi

        # Identify unique repositories containing the packages in the new list paths and create a separate list
        package_path_in_ros_ws=$(find . -type d -name "${next_packages_arry[0]}" -exec test -e "{}/package.xml" \; -print -quit)
        if [[ -z "$package_path_in_ros_ws" ]]; then
          echo "The package_path_in_ros_ws value is empty."
          exit
        fi

        next_repo=$(echo $package_path_in_ros_ws | cut -d'/' -f2)
        next_package_path=$(echo $package_path_in_ros_ws | cut -d'/' -f3-)

        recursion_ends="false"
        if [[ -z "$next_package_path" ]]; then
          echo "The package_path_in_ros_ws value is empty."
          next_package_path="."
          recursion_ends="true"
        fi
        echo "recursion_ends=$recursion_ends" >> "$GITHUB_OUTPUT"
        if [[ $recursion_ends == "false" ]]; then
          # Trigger workflow using GitHub API
          echo "next packages: ${build_order_arry[@]}"
          echo "next repo: $next_repo"
          echo "next package: $next_package_path"
          # response=$(curl -s -o /dev/null -w "%{http_code}" -X POST https://api.github.com/repos/$REPO_OWNER/$next_repo/actions/workflows/dev-ci.yaml/dispatches -H "Accept: application/vnd.github.v3+json" -H "Authorization: token $GH_TOKEN" --data '{"ref": "'$BRANCH'", "inputs": {"packages_build_paths": "'$next_package_path'"}}')
          echo "'$amd_instance_id'"
          echo "'$label_amd'"
          echo "'$arm_instance_id'"
          echo "'$label_arm'"
          response=$(curl -s -o /dev/null -w "%{http_code}" -X POST https://api.github.com/repos/$REPO_OWNER/$next_repo/actions/workflows/CI.yaml/dispatches -H "Accept: application/vnd.github.v3+json" -H "Authorization: token $GH_TOKEN" --data '{"ref": "'$BRANCH'", "inputs": {"packages_build_paths": "'$next_package_path'", "runner_amd_lable": "'$label_amd'", "runner_arm_lable": "'$label_arm'", "runner_arm_id": "'$arm_instance_id'", "runner_amd_id": "'$amd_instance_id'"}}')          
          if [ "$response" -ne 204 ]; then
            echo "Failed to trigger the workflow. HTTP status was: $response"
            exit 1
          fi
        fi

    - name: Discard Local Changes
      ## checks if changed packages, on release branch also checks for full build tag
      if: ${{ always() }}
      run: |
        cd $GITHUB_WORKSPACE
        git checkout -- .
        git clean -f

    - name: Post to a Slack channel
      if: ${{ always() }}
      id: slack
      uses: slackapi/slack-github-action@v1.23.0
      with:
        # Slack channel id, channel name, or user id to post message.
        # See also: https://api.slack.com/methods/chat.postMessage#channels
        # You can pass in multiple channels to post to by providing a comma-delimited list of channel IDs.
        channel-id: 'C051SPVTW2Z'
        # For posting a simple plain text message
        slack-message: "GitHub build result: ${{ job.status }}\nWorkflow: ${{ github.job }}\nRepository: ${{ github.event.repository.name }}\nBranch: ${{ github.ref_name }}\nBuild Number: ${{ github.run_number }}\n${{ github.event.pull_request.html_url || github.event.head_commit.url }}"
      env:
        SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
        
  stop-runners:
    needs: [initiate-workflow, arm_build, amd_build, depends_on_trigger]
    runs-on: ubuntu-20.04
    if: ${{ needs.depends_on_trigger.result == 'success' && needs.depends_on_trigger.outputs.recursion_ends == 'true' || failure() || cancelled() }}
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.CI_AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.CI_AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Stop AMD runner
        uses: Amir-civ/ec2-github-runner@main
        with:
          mode: stop
          github-token: ${{ secrets.gh_token }}
          label: ${{ needs.initiate-workflow.outputs.label-amd }}
          ec2-instance-id: ${{ needs.initiate-workflow.outputs.amd-instance-id }}

      - name: Stop ARM runner
        uses: Amir-civ/ec2-github-runner@main
        with:
          mode: stop
          github-token: ${{ secrets.gh_token }}
          label: ${{ needs.initiate-workflow.outputs.label-arm }}
          ec2-instance-id: ${{ needs.initiate-workflow.outputs.arm-instance-id }}