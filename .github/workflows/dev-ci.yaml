name: dev-ci

on:
  workflow_dispatch:
    inputs:
      packages_build_paths:
        description: 'intput packages paths to build seperated by spaces'
        required: true
        default: ''
  push:
    # branches-ignore:
      # - 'v[0-9]+.[0-9]+'
  pull_request:
    branches:
      - develop
      - 'v[0-9]+.[0-9]+'
          
concurrency: lock-${{ github.ref }}

env:
  WORKSPACE_PATH: ${{ github.workspace }}
  COMMIT_ID: ${{ github.sha }}
  BUILD_NUMBER: ${{ github.run_number }}
  BRANCH: ${{ github.ref_name }}
  REPO_OWNER: ${{ github.repository_owner }}
  REPO: ${{ github.event.repository.name }}
  ROS_DIR: $HOME/git/ros2_ws/src/
  ARTIFACTORY_ROSDEP_FILE: ${{ secrets.rosdep_map_file }}
  ARTIFACTORY_TOKEN: ${{ secrets.artifactory_token }}
  ARTIFACTORY_URL: civrobotics.jfrog.io/artifactory/civros-unstable
  GH_TOKEN: ${{ secrets.gh_token }}
  ECR_DOCKER_IMAGE: 543341912885.dkr.ecr.us-east-1.amazonaws.com/civros_container:latest
  AWS_REGION: us-east-1

jobs:
  build_amd:
    runs-on: ubuntu-20.04
    steps:

      - name: checkout
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: list all
        run: |
          pwd
          ls

      - name: Check release full build
        if: contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$')
        run: |
          # Run the command to check if the full build tag exists in civros-release
          FULL_BUILD_TAG=$(git ls-remote --refs --tags https://github.com/Civdrone/civros-release.git "${BRANCH}-promoted" | awk '{print $2}' | sed 's/refs\/tags\///')
          if [ -z "$FULL_BUILD_TAG" ]; then
            echo "FULL_BUILD_TAG variable is empty"
          else
            echo "TAG variable is not empty, value is: $FULL_BUILD_TAG"
            echo "FULL_BUILD_TAG=true" >> $GITHUB_ENV
          fi

      - name: Get unique changed packages
        ## checks if trigger on push event, on release branch also checks for full build tag
        if: ${{ github.event_name == 'push' && !contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') || contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') && env.FULL_BUILD_TAG == 'true' && github.event_name == 'push' }}
        run: |
          mapfile -t CHANGED_FILES < <(git diff --name-only ${{ github.event.before }} ${{ github.event.after }})
          # Initialize unique_packages_paths
          unique_packages_paths=()

          for path in "${CHANGED_FILES[@]}"; do
            # if the path is a hidden directory or file, skip to the next iteration
            if [[ $path == .* ]]; then
              continue
            fi
            current_dirname="$(realpath "$path")"
            has_package_xml=false
            while [[ "$current_dirname" != "${GITHUB_WORKSPACE}" && $has_package_xml == false ]]; do
              current_dirname=$(dirname "$current_dirname")
              if [[ -f "${current_dirname}/package.xml" ]]; then
                has_package_xml=true
              fi
            done

            # Add if package.xml was found
            if [[ $has_package_xml == true ]]; then
              unique_packages_paths+=("$current_dirname")
            fi
          done

          # Remove duplicates from the unique_packages_paths list
          unique_packages_paths=($(for path in "${unique_packages_paths[@]}"; do
            echo "$path"
          done | sort -u))

          # Output the list of unique packages paths
          echo "Changed packages: ${unique_packages_paths[@]}"

          # Set the `changed_packages_paths` environment variable with the list of unique packages paths
          echo "changed_packages_paths=${unique_packages_paths[*]}" >> $GITHUB_ENV

      - name: Get workflow manual input
        ## checks if trigger on dispatch event, on release branch also checks for full build tag
        if: ${{ github.event_name == 'workflow_dispatch' && !contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') || contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') && env.FULL_BUILD_TAG == 'true' && github.event_name == 'workflow_dispatch' }}
        run: |
          # Split the input paths by spaces and store them in an array
          IFS=' ' read -ra paths <<< "${{ github.event.inputs.packages_build_paths }}"
          
          # Initialize an empty string to store the converted absolute paths
          converted_paths=""
          
          # Iterate over the paths array and convert each path to an absolute path using realpath
          for path in "${paths[@]}"; do
            absolute_path=$(realpath "$path")
            converted_paths+=" $absolute_path"
          done
          
          # Remove leading space from the converted_paths string
          converted_paths="${converted_paths:1}"
          
          # Set the converted_paths string as the value in changed_packages_paths
          echo "changed_packages_paths=$converted_paths" >> $GITHUB_ENV
          
      - name: Update artifactory server
      ## checks if changed packages, on release branch also checks for full build tag
        if: ${{ env.changed_packages_paths != '' && !contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') || contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') && env.FULL_BUILD_TAG == 'true' && env.changed_packages_paths != '' }}
        run: |
          echo $REPO_OWNER
          echo $REPO
          echo $BRANCH
          branches=$(git for-each-ref --sort=-committerdate refs/remotes/origin --format='%(refname:short)' | cut -d / -f 2- | tr '\n' ' ')
          default_branch=$(curl -H "Authorization: token $GH_TOKEN" -s https://api.github.com/repos/$REPO_OWNER/$REPO | jq -r '.default_branch')
          echo $default_branch
          sudo touch /etc/apt/sources.list.d/civ.list
          sudo bash -c 'cat > /etc/apt/preferences.d/10-civ.pref << EOF
          Package: *
          Pin: release c='"$BRANCH"'
          Pin-Priority: 1001
          
          EOF'          
          sudo cat /etc/apt/preferences.d/10-civ.pref
          for branch in $branches; do
              echo "Branch name: $branch"
          done
          sudo sh -c "echo 'deb https://amir_b:$ARTIFACTORY_TOKEN@$ARTIFACTORY_URL galactic $BRANCH' >> /etc/apt/sources.list.d/civ.list"
          sudo sh -c "echo 'deb https://amir_b:$ARTIFACTORY_TOKEN@$ARTIFACTORY_URL galactic $default_branch' >> /etc/apt/sources.list.d/civ.list"
          sudo sh -c "echo 'deb https://amir_b:$ARTIFACTORY_TOKEN@$ARTIFACTORY_URL galactic main' >> /etc/apt/sources.list.d/civ.list"
          sudo cat /etc/apt/sources.list.d/civ.list
          wget -O civrobotics.pub https://amir_b:$ARTIFACTORY_TOKEN@civrobotics.jfrog.io/artifactory/api/security/keypair/debianKeys/public
          gpg --import civrobotics.pub
          gpg --list-keys
          sudo apt-key add civrobotics.pub
          sudo apt update

      - name: install external packages
        ## checks if changed packages, on release branch also checks for full build tag
        if: ${{ env.changed_packages_paths != '' && !contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') || contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') && env.FULL_BUILD_TAG == 'true' && env.changed_packages_paths != '' }}
        run: |
          mkdir external_packages
          cd external_packages
          echo "Json Package Install"
          wget https://github.com/nlohmann/json/releases/download/v3.10.4/include.zip
          sudo unzip include.zip -d /usr/
          echo "Serial Port Package Install"
          git clone https://Amir-civ:$GH_TOKEN@github.com/Civdrone/CppLinuxSerial.git
          cd CppLinuxSerial
          git checkout v2.3.0
          mkdir build
          cd build
          cmake ..
          sudo make install

      - name: Ros Install
        ## checks if changed packages, on release branch also checks for full build tag
        if: ${{ env.changed_packages_paths != '' && !contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') || contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') && env.FULL_BUILD_TAG == 'true' && env.changed_packages_paths != '' }}
        run: |
          sudo apt update && sudo apt install locales
          sudo locale-gen en_US en_US.UTF-8
          sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8
          export LANG=en_US.UTF-8
          locale
          sudo apt install software-properties-common -y
          sudo add-apt-repository universe
          sudo apt update && sudo apt install curl gnupg lsb-release -y
          curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key  -o /usr/share/keyrings/ros-archive-keyring.gpg
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(source /etc/os-release && echo $UBUNTU_CODENAME) main" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null
          sudo apt update
          sudo apt install ros-galactic-ros-base

      - name: check os and ros versions
        ## checks if changed packages, on release branch also checks for full build tag
        if: ${{ env.changed_packages_paths != '' && !contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') || contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') && env.FULL_BUILD_TAG == 'true' && env.changed_packages_paths != '' }}
        run: |
          lsb_release -a
          dpkg --print-architecture
          ls /opt/ros/

      - name: additional env installations
        ## checks if changed packages, on release branch also checks for full build tag
        if: ${{ env.changed_packages_paths != '' && !contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') || contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') && env.FULL_BUILD_TAG == 'true' && env.changed_packages_paths != '' }}
        run: |
          pip3 install scipy
          sudo apt-get install ros-galactic-pluginlib -y
          sudo apt-get install ros-galactic-nmea-msgs -y
          sudo apt update
          sudo apt install ros-galactic-robot-localization -y
          sudo apt install ros-galactic-launch* -y
          sudo apt install ros-galactic-gps-msgs -y
          sudo apt install python3-pip -y
          sudo -H pip3 install -U argcomplete
          sudo apt install python3-colcon-common-extensions -y
          sudo apt install ros-dev-tools -y
          sudo apt install libboost-all-dev -y
          sudo apt install libpcap-dev -y
          sudo apt install python3-bloom fakeroot dh-make -y
          pip install setuptools==58.2.0
   
      - name: install rosdep
        ## checks if changed packages, on release branch also checks for full build tag
        if: ${{ env.changed_packages_paths != '' && !contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') || contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') && env.FULL_BUILD_TAG == 'true' && env.changed_packages_paths != '' }}
        run: |
          echo "Install rosdep"
          sudo apt upgrade -y
          sudo apt install python3-rosdep -y
          sudo rosdep init -y 
          sudo rosdep fix-permissions
          rosdep update -y
          sudo curl -u "Amir-civ:$GH_TOKEN" -L $ARTIFACTORY_ROSDEP_FILE -o /etc/ros/rosdep/sources.list.d/local.yaml
          if [ $? -eq 0 ]; then
            echo "YAML file downloaded successfully!"
          else
            echo "Failed to download YAML file."
          fi
          sudo sh -c 'echo "yaml file:///etc/ros/rosdep/sources.list.d/local.yaml" >> /etc/ros/rosdep/sources.list.d/20-default.list'

      - name: install mavros
        ## checks if changed packages, on release branch also checks for full build tag
        if: ${{ env.changed_packages_paths != '' && !contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') || contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') && env.FULL_BUILD_TAG == 'true' && env.changed_packages_paths != '' }}
        run: |
          wget https://raw.githubusercontent.com/mavlink/mavros/master/mavros/scripts/install_geographiclib_datasets.sh
          sudo apt-get install ros-galactic-mavros ros-galactic-mavros-extras -y
          sudo chmod +x ./install_geographiclib_datasets.sh && sudo ./install_geographiclib_datasets.sh

      - name: install rosbridge server
        ## checks if changed packages, on release branch also checks for full build tag
        if: ${{ env.changed_packages_paths != '' && !contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') || contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') && env.FULL_BUILD_TAG == 'true' && env.changed_packages_paths != '' }}
        run: sudo apt install ros-galactic-rosbridge-server -y

      - name: Build deb package
        ## checks if changed packages, on release branch also checks for full build tag
        if: ${{ env.changed_packages_paths != '' && !contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') || contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') && env.FULL_BUILD_TAG == 'true' && env.changed_packages_paths != '' }}
        id: build_deb_package
        run: |
          built_packages=true
          IFS=' ' read -ra packages_paths <<< "$changed_packages_paths"
          for package_path in "${packages_paths[@]}"; do
            pwd
            ls
            cd "$package_path"
            pwd
            ls
            sed -E -i "s/<version>([0-9]+)\.([0-9]+)\.([0-9]+)<\/version>/<version>\1.\2.${BUILD_NUMBER}<\/version>/" package.xml
            source /opt/ros/galactic/setup.bash
            rosdep update --include-eol-distros
            bloom-generate rosdebian
            sudo apt update
            sudo apt build-dep .
            dpkg-buildpackage -b -rfakeroot -us -uc
            cd ..
            # ls | grep .deb
            if ! ls *.deb 1>/dev/null 2>&1; then
              built_packages=false
            fi
          done
          echo "built_packages=$built_packages" >> $GITHUB_ENV

      - name: Push to artifactory server
        ## checks if changed packages & built packages, on release branch also checks for full build tag
        if: ${{ env.changed_packages_paths != '' && env.built_packages == 'true' && !contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') || contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') && env.FULL_BUILD_TAG == 'true' && env.changed_packages_paths != '' && env.built_packages == 'true' }}
        run: |
          # convert the list to an array
          IFS=' ' read -ra changed_packages_paths_arry <<< "$changed_packages_paths"

          # use an associative array(bash dictionary) to handle duplicates
          declare -A debian_packages_paths

          # loop over each path, get the dirname and add it to the associative array(bash dictionary)
          for i in "${changed_packages_paths_arry[@]}"; do
            dirname=$(dirname "$i")
            debian_packages_paths["$dirname"]=1
          done

          # now debian_packages_paths is a list with unique directories, so we can iterate over it
          for dir in "${!debian_packages_paths[@]}"; do
            echo "Processing directory $dir"
            cd "$dir"
            
            # your script comes here
            PACKS=($(ls ${1:-.}/*.deb))
            echo "$PACKS"
            for pack in "${PACKS[@]}"
            do
                name=$(basename "$pack")
                printf "\nPublishing %s\n" "$name"
                
                dirname=$(cut -d '_' -f1 <<< "$name")
                #push them to Artifactory
                curl --fail -uamir_b:$ARTIFACTORY_TOKEN -XPUT "https://$ARTIFACTORY_URL/galactic/${dirname}/${BRANCH}/${name};deb.distribution=galactic;deb.component=$BRANCH;deb.architecture=$(dpkg --print-architecture);deb.build_number=$BUILD_NUMBER" -T $pack -o $dirname.json
                cat $dirname.json
            done

            # get back to the initial directory, so that relative paths work in the next iteration
            cd -
          done

      - name: Update rosdep yaml file
        ## checks if changed packages_paths & built packages, on release branch also checks for full build tag
        if: ${{ env.changed_packages_paths != '' && env.built_packages == 'true' && !contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') || contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') && env.FULL_BUILD_TAG == 'true' && env.changed_packages_paths != '' && env.built_packages == 'true' }}
        run: |
          git clone https://"Amir-civ:$GH_TOKEN"@github.com/Civdrone/scripts.git
          cd scripts
          git checkout ci-github-actions
          IFS=' ' read -ra packages_paths <<< "$changed_packages_paths"
          for package_path in "${packages_paths[@]}"; do
            # Check if package path is root
            if [[ $package_path == "." ]]; then
              package_name=$REPO
            else
              package_name=$(basename "$package_path")
            fi
      
            package_exists=$(yq ".$package_name" ./docker_container/local.yaml)
            if [[ $package_exists = null ]]; then
              # Define the apt package
              apt_package=$(echo "$package_name" | sed 's/_/-/g; s/^/ros-galactic-/')
              
              # Create the YAML content for the new package
              new_yaml_content="${package_name}:\n  ubuntu:\n    focal: [${apt_package}]"
              
              # Read the existing YAML content from the file
              existing_yaml_content=$(sudo cat ./docker_container/local.yaml)
              
              # Append the new package information to the existing YAML content
              yaml_content="${existing_yaml_content}\n${new_yaml_content}"
              
              # Write the modified YAML content to the file
              echo -e "${yaml_content}" > ./docker_container/local.yaml
              # Push changes to remote
              git config --global user.email "amir@civrobotics.com"
              git config --global user.name "amir-ci"
              git add .
              git commit -m "changed rosdep yaml file from ci, owner/repo: ${REPO}, branch: ${BRANCH}  build number: ${BUILD_NUMBER}."
              git push origin ci-github-actions
            else
              echo "$package_name exists"
            fi
          done       

      - name: Update commit status and cencel all workflows with the same branch on failure
        if: ${{ failure() }}
        run: |
          sudo curl -u "Amir-civ:$GH_TOKEN" -L https://raw.githubusercontent.com/$REPO_OWNER/civros-release/main/repo.csv -o ./repo.csv
          if [ $? -eq 0 ]; then
              echo "repo.csv file downloaded successfully!"
          else
              echo "Failed to download repo.csv file."
          fi
          # Read the CSV file and cencel repositories
          while IFS=, read -r repo || [ -n "$repo" ]; do
            # Get the most recent workflow run ID for the specified branch
            run_id=$(curl -s -H "Authorization: Bearer $GH_TOKEN" \
            "https://api.github.com/repos/$REPO_OWNER/$repo/actions/runs?branch=$BRANCH&event=push" \
            | jq -r '.workflow_runs[0].id')

            # Cancel the workflow run
            curl -X POST -s -H "Authorization: Bearer $GH_TOKEN" \
            "https://api.github.com/repos/$REPO_OWNER/$repo/actions/runs/$run_id/cancel"

            echo "Workflow run $run_id has been canceled"
          done < ./repo.csv
          # update commit status
          curl -X POST -H "Authorization: token $GH_TOKEN" -H "Accept: application/vnd.github.v3+json" https://api.github.com/repos/$REPO_OWNER/$REPO/statuses/${COMMIT_ID} -d '{"state": "failure", "context": "continuous-integration/build-${BUILD_NUMBER"}'

      - name: Discard Local Changes
        ## checks if changed packages, on release branch also checks for full build tag
        if: ${{ env.changed_packages_paths != '' && !contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') || contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') && env.FULL_BUILD_TAG == 'true' && env.changed_packages_paths != '' }}
        run: |
          cd $GITHUB_WORKSPACE
          git checkout -- .
          git clean -f
          
      - name: Post to a Slack channel
        if: ${{ always() }}
        id: slack
        uses: slackapi/slack-github-action@v1.23.0
        with:
          # Slack channel id, channel name, or user id to post message.
          # See also: https://api.slack.com/methods/chat.postMessage#channels
          # You can pass in multiple channels to post to by providing a comma-delimited list of channel IDs.
          channel-id: 'C051SPVTW2Z'
          # For posting a simple plain text message
          slack-message: "GitHub build result: ${{ job.status }}\nWorkflow: ${{ github.job }}\nRepository: ${{ github.event.repository.name }}\nBranch: ${{ github.ref_name }}\nBuild Number: ${{ github.run_number }}\n${{ github.event.pull_request.html_url || github.event.head_commit.url }}"
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}

  build_arm:
    runs-on: ubuntu-20.04
    steps:

    - name: checkout
      uses: actions/checkout@v3
      with:
        fetch-depth: 0

    - name: check os and ros versions
      run: |
        lsb_release -a
        dpkg --print-architecture

    - name: list all
      run: |
        pwd
        ls

    - name: Check release full build
      if: contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$')
      run: |
        # Run the command to check if the full build tag exists in civros-release
        FULL_BUILD_TAG=$(git ls-remote --refs --tags https://github.com/Civdrone/civros-release.git "${BRANCH}-promoted" | awk '{print $2}' | sed 's/refs\/tags\///')
        if [ -z "$FULL_BUILD_TAG" ]; then
          echo "FULL_BUILD_TAG variable is empty"
        else
          echo "TAG variable is not empty, value is: $FULL_BUILD_TAG"
          echo "FULL_BUILD_TAG=true" >> $GITHUB_ENV
        fi

    - name: Get unique changed packages
      ## checks if trigger on push event, on release branch also checks for full build tag
      if: ${{ github.event_name == 'push' && !contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') || contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') && env.FULL_BUILD_TAG == 'true' && github.event_name == 'push' }}
      run: |
        mapfile -t CHANGED_FILES < <(git diff --name-only ${{ github.event.before }} ${{ github.event.after }})
        # Initialize unique_packages_paths
        unique_packages_paths=()

        for path in "${CHANGED_FILES[@]}"; do
          # if the path is a hidden directory or file, skip to the next iteration
          if [[ $path == .* ]]; then
            continue
          fi
          current_dirname="$(realpath "$path")"
          has_package_xml=false
          while [[ "$current_dirname" != "${GITHUB_WORKSPACE}" && $has_package_xml == false ]]; do
            current_dirname=$(dirname "$current_dirname")
            if [[ -f "${current_dirname}/package.xml" ]]; then
              has_package_xml=true
            fi
          done

          # Add if package.xml was found
          if [[ $has_package_xml == true ]]; then
            unique_packages_paths+=("$current_dirname")
          fi
        done

        # Remove duplicates from the unique_packages_paths list
        unique_packages_paths=($(for path in "${unique_packages_paths[@]}"; do
          echo "$path"
        done | sort -u))

        # Output the list of unique packages paths
        echo "Changed packages: ${unique_packages_paths[@]}"

        # Set the `changed_packages_paths` environment variable with the list of unique packages paths
        echo "changed_packages_paths=${unique_packages_paths[*]}" >> $GITHUB_ENV

    - name: Get workflow manual input
      ## checks if trigger on dispatch event, on release branch also checks for full build tag
      if: ${{ github.event_name == 'workflow_dispatch' && !contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') || contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') && env.FULL_BUILD_TAG == 'true' && github.event_name == 'workflow_dispatch' }}
      run: |
        # Split the input paths by spaces and store them in an array
        IFS=' ' read -ra paths <<< "${{ github.event.inputs.packages_build_paths }}"
        
        # Initialize an empty string to store the converted absolute paths
        converted_paths=""
        
        # Iterate over the paths array and convert each path to an absolute path using realpath
        for path in "${paths[@]}"; do
          absolute_path=$(realpath "$path")
          converted_paths+=" $absolute_path"
        done
        
        # Remove leading space from the converted_paths string
        converted_paths="${converted_paths:1}"
        
        # Set the converted_paths string as the value in changed_packages_paths
        echo "changed_packages_paths=$converted_paths" >> $GITHUB_ENV

    - name: Configure AWS credentials
      ## checks if changed packages, on release branch also checks for full build tag
      if: ${{ env.changed_packages_paths != '' && !contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') || contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') && env.FULL_BUILD_TAG == 'true' && env.changed_packages_paths != '' }}
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Set up QEMU
      ## checks if changed packages, on release branch also checks for full build tag
      if: ${{ env.changed_packages_paths != '' && !contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') || contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') && env.FULL_BUILD_TAG == 'true' && env.changed_packages_paths != '' }}
      uses: docker/setup-qemu-action@v2

    - name: Run docker and build deb
      ## checks if changed packages, on release branch also checks for full build tag
      if: ${{ env.changed_packages_paths != '' && !contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') || contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') && env.FULL_BUILD_TAG == 'true' && env.changed_packages_paths != '' }}
      run: |
        aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 543341912885.dkr.ecr.us-east-1.amazonaws.com        # changed_packages_string=$(printf '%s ' "${changed_packages_paths[@]}")
        docker run -itd --name cross-c --entrypoint=/bin/bash -v $(pwd):/home/civrobotics/cross/$REPO -e ARTIFACTORY_TOKEN=$ARTIFACTORY_TOKEN -e ARTIFACTORY_URL=$ARTIFACTORY_URL -e GH_TOKEN=$GH_TOKEN -e REPO_OWNER=$REPO_OWNER -e REPO=$REPO -e BRANCH=$BRANCH -e BUILD_NUMBER=${{ github.run_number }} -e changed_packages_paths="$changed_packages_paths" -e ARTIFACTORY_ROSDEP_FILE="$ARTIFACTORY_ROSDEP_FILE" -e GITHUB_WORKSPACE="$GITHUB_WORKSPACE" ${{ env.ECR_DOCKER_IMAGE }}
        docker exec cross-c bash /usr/local/bin/cross_deb_entrypoint.sh

    - name: Update commit status and cencel all workflows with the same branch on failure
      if: ${{ failure() }}
      run: |
        sudo curl -u "Amir-civ:$GH_TOKEN" -L https://raw.githubusercontent.com/$REPO_OWNER/civros-release/main/repo.csv -o ./repo.csv
        if [ $? -eq 0 ]; then
            echo "repo.csv file downloaded successfully!"
        else
            echo "Failed to download repo.csv file."
        fi
        # Read the CSV file and cencel repositories
        while IFS=, read -r repo || [ -n "$repo" ]; do
          # Get the most recent workflow run ID for the specified branch
          run_id=$(curl -s -H "Authorization: Bearer $GH_TOKEN" \
          "https://api.github.com/repos/$REPO_OWNER/$repo/actions/runs?branch=$BRANCH&event=push" \
          | jq -r '.workflow_runs[0].id')

          # Cancel the workflow run
          curl -X POST -s -H "Authorization: Bearer $GH_TOKEN" \
          "https://api.github.com/repos/$REPO_OWNER/$repo/actions/runs/$run_id/cancel"

          echo "Workflow run $run_id has been canceled"
        done < ./repo.csv
        # update commit status
        curl -X POST -H "Authorization: token $GH_TOKEN" -H "Accept: application/vnd.github.v3+json" https://api.github.com/repos/$REPO_OWNER/$REPO/statuses/${COMMIT_ID} -d '{"state": "failure", "context": "continuous-integration/build-${BUILD_NUMBER"}'

    - name: Discard Local Changes
      ## checks if changed packages, on release branch also checks for full build tag
      if: ${{ env.changed_packages_paths != '' && !contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') || contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') && env.FULL_BUILD_TAG == 'true' && env.changed_packages_paths != '' }}
      run: |
        cd $GITHUB_WORKSPACE
        git checkout -- .
        git clean -f

    - name: Post to a Slack channel
      if: ${{ always() }}
      id: slack
      uses: slackapi/slack-github-action@v1.23.0
      with:
        # Slack channel id, channel name, or user id to post message.
        # See also: https://api.slack.com/methods/chat.postMessage#channels
        # You can pass in multiple channels to post to by providing a comma-delimited list of channel IDs.
        channel-id: 'C051SPVTW2Z'
        # For posting a simple plain text message
        slack-message: "GitHub build result: ${{ job.status }}\nWorkflow: ${{ github.job }}\nRepository: ${{ github.event.repository.name }}\nBranch: ${{ github.ref_name }}\nBuild Number: ${{ github.run_number }}\n${{ github.event.pull_request.html_url || github.event.head_commit.url }}"
      env:
        SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}

  depends_on_trigger:
    needs: [build_amd, build_arm]
    if: ${{ needs.build_amd.result == 'success' && needs.build_arm.result == 'success' }} && !contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$')
    runs-on: ubuntu-20.04
    steps:
    - name: checkout
      if: ${{ !contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') }}
      uses: actions/checkout@v3
      with:
        fetch-depth: 0

    - name: Get unique changed packages
      ## checks if trigger on push event, on release branch also checks for full build tag
      if: ${{ github.event_name == 'push' && !contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') || contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') && env.FULL_BUILD_TAG == 'true' && github.event_name == 'push' }}
      run: |
        mapfile -t CHANGED_FILES < <(git diff --name-only ${{ github.event.before }} ${{ github.event.after }})
        # Initialize unique_packages_paths
        unique_packages_paths=()

        for path in "${CHANGED_FILES[@]}"; do
          # if the path is a hidden directory or file, skip to the next iteration
          if [[ $path == .* ]]; then
            continue
          fi
          current_dirname="$(realpath "$path")"
          has_package_xml=false
          while [[ "$current_dirname" != "${GITHUB_WORKSPACE}" && $has_package_xml == false ]]; do
            current_dirname=$(dirname "$current_dirname")
            if [[ -f "${current_dirname}/package.xml" ]]; then
              has_package_xml=true
            fi
          done

          # Add if package.xml was found
          if [[ $has_package_xml == true ]]; then
            unique_packages_paths+=("$current_dirname")
          fi
        done

        # Remove duplicates from the unique_packages_paths list
        unique_packages_paths=($(for path in "${unique_packages_paths[@]}"; do
          echo "$path"
        done | sort -u))

        # Output the list of unique packages paths
        echo "Changed packages: ${unique_packages_paths[@]}"

        # Set the `changed_packages_paths` environment variable with the list of unique packages paths
        echo "changed_packages_paths=${unique_packages_paths[*]}" >> $GITHUB_ENV

    - name: Get workflow manual input
      ## checks if trigger on dispatch event, on release branch also checks for full build tag
      if: ${{ github.event_name == 'workflow_dispatch' && !contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') || contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') && env.FULL_BUILD_TAG == 'true' && github.event_name == 'workflow_dispatch' }}
      run: |
        # Split the input paths by spaces and store them in an array
        IFS=' ' read -ra paths <<< "${{ github.event.inputs.packages_build_paths }}"
        
        # Initialize an empty string to store the converted absolute paths
        converted_paths=""
        
        # Iterate over the paths array and convert each path to an absolute path using realpath
        for path in "${paths[@]}"; do
          absolute_path=$(realpath "$path")
          converted_paths+=" $absolute_path"
        done
        
        # Remove leading space from the converted_paths string
        converted_paths="${converted_paths:1}"
        
        # Set the converted_paths string as the value in changed_packages_paths
        echo "changed_packages_paths=$converted_paths" >> $GITHUB_ENV
        
    - name: Ros Install
      ## checks if changed packages, on release branch also checks for full build tag
      if: ${{ env.changed_packages_paths != '' && !contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') || contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') && env.FULL_BUILD_TAG == 'true' && env.changed_packages_paths != '' }}
      run: |
        sudo apt update && sudo apt install locales
        sudo locale-gen en_US en_US.UTF-8
        sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8
        export LANG=en_US.UTF-8
        locale
        sudo apt install software-properties-common -y
        sudo add-apt-repository universe
        sudo apt update && sudo apt install curl gnupg lsb-release -y
        curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key  -o /usr/share/keyrings/ros-archive-keyring.gpg
        echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(source /etc/os-release && echo $UBUNTU_CODENAME) main" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null
        sudo apt update
        sudo apt install ros-galactic-ros-base
        echo "installing colcon"
        sudo apt install python3-colcon-common-extensions -y

    - name: Trigger task that depends on packages
      if: ${{ env.changed_packages_paths != '' && !contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') || contains(env.BRANCH, '^v[0-9]+\\.[0-9]+$') && env.FULL_BUILD_TAG == 'true' && env.changed_packages_paths != '' }}
      run: |
        echo "Changed package paths: $changed_packages_paths"
        mkdir ros_ws && cd ros_ws
        # Download repo.csv
        sudo curl -u "Amir-civ:$GH_TOKEN" -L https://raw.githubusercontent.com/Civdrone/civros-release/main/repo.csv -o ./repo.csv
        if [ $? -eq 0 ]; then
            echo "repo.csv file downloaded successfully!"
        else
            echo "Failed to download repo.csv file."
        fi
        
        # Read the CSV file and clone repositories
        while IFS=, read -r repo || [ -n "$repo" ]; do
            git clone https://"$Amir-civ":"${GH_TOKEN}"@github.com/$REPO_OWNER/"$repo".git
        done < ./repo.csv
        
        # Source ROS 2 Galactic installation
        source /opt/ros/galactic/setup.bash
        
        # Run colcon list --topological-order command and extract the first fraction from each line
        build_order=$(colcon list --topological-order | awk '{print $1}')
        # IFS=' ' read -ra build_order_arry <<< "$build_order"
        # IFS=' ' read -ra packages_paths_arry <<< "$changed_packages_paths"
        build_order_arry=($build_order)
        packages_paths_arry=($changed_packages_paths)

        for i in "${!build_order_arry[@]}"; do
            for package_path in "${packages_paths_arry[@]}"; do
                if [[ ${build_order_arry[$i]} = $(basename "$package_path") ]]; then
                    next_packages_arry=("${build_order_arry[@]:$((i+1))}")
                    break 2
                fi
            done
        done

        if [[ ${#next_packages_arry[@]} -gt 0 ]]; then
            echo "next package: ${next_packages_arry[0]}"
        else
            echo "No next packages found."
        fi

        # Identify unique repositories containing the packages in the new list paths and create a separate list
        package_path_in_ros_ws=$(find . -type d -name "${next_packages_arry[0]}" -exec test -e "{}/package.xml" \; -print -quit)
        if [[ -z "$package_path_in_ros_ws" ]]; then
          echo "The package_path_in_ros_ws value is empty."
          exit
        fi

        next_repo=$(echo $package_path_in_ros_ws | cut -d'/' -f2)
        next_package_path=$(echo $package_path_in_ros_ws | cut -d'/' -f3-)

        if [[ -z "$next_package_path" ]]; then
          echo "The package_path_in_ros_ws value is empty."
          next_package_path="."
        fi

        # Trigger workflow using GitHub API
        echo "next packages: ${build_order}"
        echo "next repo: $next_repo"
        echo "next package: $next_package_path"
        response=$(curl -s -o /dev/null -w "%{http_code}" -X POST https://api.github.com/repos/$REPO_OWNER/$next_repo/actions/workflows/dev-ci.yaml/dispatches -H "Accept: application/vnd.github.v3+json" -H "Authorization: token $GH_TOKEN" --data '{"ref": "'$BRANCH'", "inputs": {"packages_build_paths": "'$next_package_path'"}}')
        if [ "$response" -ne 204 ]; then
          echo "Failed to trigger the workflow. HTTP status was: $response"
          exit 1
        fi
        
    - name: Post to a Slack channel
      if: ${{ always() }}
      id: slack
      uses: slackapi/slack-github-action@v1.23.0
      with:
        # Slack channel id, channel name, or user id to post message.
        # See also: https://api.slack.com/methods/chat.postMessage#channels
        # You can pass in multiple channels to post to by providing a comma-delimited list of channel IDs.
        channel-id: 'C051SPVTW2Z'
        # For posting a simple plain text message
        slack-message: "GitHub build result: ${{ job.status }}\nWorkflow: ${{ github.job }}\nRepository: ${{ github.event.repository.name }}\nBranch: ${{ github.ref_name }}\nBuild Number: ${{ github.run_number }}\n${{ github.event.pull_request.html_url || github.event.head_commit.url }}"
      env:
        SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}